<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Libra: liblibra::libcell Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Libra
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceliblibra.html">liblibra</a></li><li class="navelem"><a class="el" href="namespaceliblibra_1_1libcell.html">libcell</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">liblibra::libcell Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>libcell namespace  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structliblibra_1_1libcell_1_1triple.html">triple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structliblibra_1_1libcell_1_1quartet.html">quartet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structliblibra_1_1libcell_1_1excl__scale.html">excl_scale</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libcell_1_1Cell.html">Cell</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa43bc6fe7e15597a69351d1ee0c1f06e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcell.html#aa43bc6fe7e15597a69351d1ee0c1f06e">export_Cell_objects</a> ()</td></tr>
<tr class="separator:aa43bc6fe7e15597a69351d1ee0c1f06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e22de9ed8139366eaafddc61e391c4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e22de9ed8139366eaafddc61e391c4c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_PYTHON_MODULE</b> (libcell)</td></tr>
<tr class="separator:a9e22de9ed8139366eaafddc61e391c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a19de389cce3568fee74420fdf4ed8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcell.html#a95a19de389cce3568fee74420fdf4ed8">max_vector</a> (<a class="el" href="classliblibra_1_1liblinalg_1_1VECTOR.html">VECTOR</a> &amp;t1, <a class="el" href="classliblibra_1_1liblinalg_1_1VECTOR.html">VECTOR</a> &amp;t2, <a class="el" href="classliblibra_1_1liblinalg_1_1VECTOR.html">VECTOR</a> &amp;t3, <a class="el" href="classliblibra_1_1liblinalg_1_1VECTOR.html">VECTOR</a> &amp;T)</td></tr>
<tr class="separator:a95a19de389cce3568fee74420fdf4ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b944992956ffe4e84f547eafe16258"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60b944992956ffe4e84f547eafe16258"></a>
<a class="el" href="classliblibra_1_1liblinalg_1_1VECTOR.html">VECTOR</a>&#160;</td><td class="memItemRight" valign="bottom"><b>max_vector</b> (<a class="el" href="classliblibra_1_1liblinalg_1_1VECTOR.html">VECTOR</a> t1, <a class="el" href="classliblibra_1_1liblinalg_1_1VECTOR.html">VECTOR</a> t2, <a class="el" href="classliblibra_1_1liblinalg_1_1VECTOR.html">VECTOR</a> t3)</td></tr>
<tr class="separator:a60b944992956ffe4e84f547eafe16258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae98a905c8f83444a952d6069c339be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcell.html#afae98a905c8f83444a952d6069c339be">apply_pbc</a> (<a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX3x3.html">MATRIX3x3</a> &amp;H, int sz, <a class="el" href="classliblibra_1_1liblinalg_1_1VECTOR.html">VECTOR</a> *in, <a class="el" href="classliblibra_1_1liblinalg_1_1VECTOR.html">VECTOR</a> *out, vector&lt; <a class="el" href="structliblibra_1_1libcell_1_1quartet.html">quartet</a> &gt; &amp;T)</td></tr>
<tr class="separator:afae98a905c8f83444a952d6069c339be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c08543e561eb1cab5e56b5e0f8a2df5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c08543e561eb1cab5e56b5e0f8a2df5"></a>
boost::python::list&#160;</td><td class="memItemRight" valign="bottom"><b>apply_pbc</b> (<a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX3x3.html">MATRIX3x3</a> H, boost::python::list in, boost::python::list t)</td></tr>
<tr class="separator:a1c08543e561eb1cab5e56b5e0f8a2df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c86c62f5f1059e6d3d0d80bfa5722d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcell.html#a00c86c62f5f1059e6d3d0d80bfa5722d">serial_to_vector</a> (int c, int Nx, int Ny, int Nz, int &amp;nx, int &amp;ny, int &amp;nz)</td></tr>
<tr class="separator:a00c86c62f5f1059e6d3d0d80bfa5722d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b0cbd9c51b56976ea23037be07bb9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2b0cbd9c51b56976ea23037be07bb9c"></a>
boost::python::list&#160;</td><td class="memItemRight" valign="bottom"><b>serial_to_vector</b> (int c, int Nx, int Ny, int Nz)</td></tr>
<tr class="separator:ac2b0cbd9c51b56976ea23037be07bb9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b88ab9278cb700d45d8519ff38a875f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcell.html#a9b88ab9278cb700d45d8519ff38a875f">serial_to_vector_symm</a> (int c, int Nx, int Ny, int Nz, int &amp;nx, int &amp;ny, int &amp;nz)</td></tr>
<tr class="separator:a9b88ab9278cb700d45d8519ff38a875f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b1619b2a7f8ee56b5fafd7ea879e90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88b1619b2a7f8ee56b5fafd7ea879e90"></a>
boost::python::list&#160;</td><td class="memItemRight" valign="bottom"><b>serial_to_vector_symm</b> (int c, int Nx, int Ny, int Nz)</td></tr>
<tr class="separator:a88b1619b2a7f8ee56b5fafd7ea879e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62156086d498cad2f21ae68833c669a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcell.html#ac62156086d498cad2f21ae68833c669a">form_neibc</a> (int c, vector&lt; int &gt; &amp;neibc, int Nx, int Ny, int Nz, double cellx, double celly, double cellz, double Roff)</td></tr>
<tr class="separator:ac62156086d498cad2f21ae68833c669a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd4d3663deb12eeaed413082cfb3202"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dd4d3663deb12eeaed413082cfb3202"></a>
boost::python::list&#160;</td><td class="memItemRight" valign="bottom"><b>form_neibc</b> (int c, int Nx, int Ny, int Nz, double cellx, double celly, double cellz, double Roff)</td></tr>
<tr class="separator:a9dd4d3663deb12eeaed413082cfb3202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f9e18ca0a7e9f1da284eb07eeb29ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcell.html#ad1f9e18ca0a7e9f1da284eb07eeb29ce">find_min_shell</a> (<a class="el" href="classliblibra_1_1liblinalg_1_1VECTOR.html">VECTOR</a> &amp;t1, <a class="el" href="classliblibra_1_1liblinalg_1_1VECTOR.html">VECTOR</a> &amp;t2, <a class="el" href="classliblibra_1_1liblinalg_1_1VECTOR.html">VECTOR</a> &amp;t3, <a class="el" href="classliblibra_1_1liblinalg_1_1VECTOR.html">VECTOR</a> &amp;g1, <a class="el" href="classliblibra_1_1liblinalg_1_1VECTOR.html">VECTOR</a> &amp;g2, <a class="el" href="classliblibra_1_1liblinalg_1_1VECTOR.html">VECTOR</a> &amp;g3, double Roff, <a class="el" href="structliblibra_1_1libcell_1_1triple.html">triple</a> &amp;minb, <a class="el" href="structliblibra_1_1libcell_1_1triple.html">triple</a> &amp;maxb)</td></tr>
<tr class="separator:ad1f9e18ca0a7e9f1da284eb07eeb29ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848fbe138eb92c9910b8b55c6974b31f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcell.html#a848fbe138eb92c9910b8b55c6974b31f">make_nlist</a> (int Nat, <a class="el" href="classliblibra_1_1liblinalg_1_1VECTOR.html">VECTOR</a> *r, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX3x3.html">MATRIX3x3</a> &amp;H, int maxa, int maxb, int maxc, double cellx, double celly, double cellz, double Roff, vector&lt; vector&lt; <a class="el" href="structliblibra_1_1libcell_1_1quartet.html">quartet</a> &gt; &gt; &amp;nlist)</td></tr>
<tr class="separator:a848fbe138eb92c9910b8b55c6974b31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14fa855e85f37cce89dc6db2450321aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcell.html#a14fa855e85f37cce89dc6db2450321aa">make_nlist_auto</a> (int Nat, <a class="el" href="classliblibra_1_1liblinalg_1_1VECTOR.html">VECTOR</a> *r, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX3x3.html">MATRIX3x3</a> &amp;H, double cellx, double celly, double cellz, double Roff, vector&lt; vector&lt; <a class="el" href="structliblibra_1_1libcell_1_1quartet.html">quartet</a> &gt; &gt; &amp;nlist)</td></tr>
<tr class="separator:a14fa855e85f37cce89dc6db2450321aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed49860ba7fa45afee5cf29be4b1134b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcell.html#aed49860ba7fa45afee5cf29be4b1134b">energy</a> (int Nat, <a class="el" href="classliblibra_1_1liblinalg_1_1VECTOR.html">VECTOR</a> *r, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX3x3.html">MATRIX3x3</a> &amp;H, vector&lt; vector&lt; <a class="el" href="structliblibra_1_1libcell_1_1quartet.html">quartet</a> &gt; &gt; &amp;nlist)</td></tr>
<tr class="separator:aed49860ba7fa45afee5cf29be4b1134b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5948557ac8d1ed72025bfb27a380f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcell.html#adf5948557ac8d1ed72025bfb27a380f7">bruteforce</a> (int Nat, <a class="el" href="classliblibra_1_1liblinalg_1_1VECTOR.html">VECTOR</a> *r, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX3x3.html">MATRIX3x3</a> &amp;H, int maxa, int maxb, int maxc, double Roff, vector&lt; vector&lt; <a class="el" href="structliblibra_1_1libcell_1_1quartet.html">quartet</a> &gt; &gt; &amp;nlist)</td></tr>
<tr class="separator:adf5948557ac8d1ed72025bfb27a380f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>libcell namespace </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="afae98a905c8f83444a952d6069c339be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcell::apply_pbc </td>
          <td>(</td>
          <td class="paramtype">MATRIX3x3 &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; quartet &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply the periodic boundary conditions to the array of vectors</p>
<p>This function decomposes the array of vectors &lt;in&gt; of size &lt;sz&gt; into array of vectors &lt;out&gt;, such that they all belong to the box given by matrix &lt;H&gt; and positioned on global origin (0,0,0) and on the corresponding integer translation &lt;T&gt;, which are then stored. Combination of &lt;T&gt; and &lt;out&gt; contains all the information about original vectors &lt;in&gt;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">H</td><td>The matrix containing the parameters of the unit cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>The number of atoms to be processed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>The pointer to the array of input atomic coordinates (unfolded) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>The pointer to the array of the output atomic coordinates (folded) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">the</td><td>array of integer vectors(in units of the cell vectors) that fold each atom into the central unit cell</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf5948557ac8d1ed72025bfb27a380f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcell::bruteforce </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX3x3 &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Roff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; quartet &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>nlist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function for the brute force formation of the neighbor list</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Nat</td><td>The number of atoms </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>The pointer to the array of atomic coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">H</td><td>Matrix describing the size and shape of the simulation cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxa</td><td>The maximal number of periodic translation of the unit cell along a axis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxb</td><td>The maximal number of periodic translation of the unit cell along b axis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxc</td><td>The maximal number of periodic translation of the unit cell along c axis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cellx</td><td>The size of the sub-cells in x direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">celly</td><td>The size of the sub-cells in y direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cellz</td><td>The size of the sub-cells in z direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Roff</td><td>The cutoff distance which controls the formation of the neighbor list </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">nlist</td><td>Indices of the neighboring sub-cells for all sub-cells</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aed49860ba7fa45afee5cf29be4b1134b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double liblibra::libcell::energy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX3x3 &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; quartet &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>nlist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Auxiliary function to test neighbor list</p>
<p>The function computes the sum of distances from all atoms to all their replicas</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Nat</td><td>The number of atoms </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>The pointer to the array of atomic coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">H</td><td>Matrix describing the size and shape of the simulation cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nlist</td><td>The neighbor list for all atoms</td></tr>
  </table>
  </dd>
</dl>
<p>The function returs the computed sum - to serve a the quantitative descriptor of summation</p>

</div>
</div>
<a class="anchor" id="aa43bc6fe7e15597a69351d1ee0c1f06e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcell::export_Cell_objects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exporter of libcell classes and functions</p>

</div>
</div>
<a class="anchor" id="ad1f9e18ca0a7e9f1da284eb07eeb29ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcell::find_min_shell </td>
          <td>(</td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>t3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>g3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Roff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">triple &amp;&#160;</td>
          <td class="paramname"><em>minb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">triple &amp;&#160;</td>
          <td class="paramname"><em>maxb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a minimal shell around given central unit cell</p>
<p>This function calculates the minimal shell for the given cell shape which will satisfy the condition: n1*t1.x + n2*t2.x + n3*t3.x +/- |maxT.x| &gt;= Roff n1*t1.y + n2*t2.y + n3*t3.y +/- |maxT.y| &gt;= Roff n1*t1.z + n2*t2.z + n3*t3.z +/- |maxT.z| &gt;= Roff minb,maxb - are the triples, corresponding to minimal (left,down) and maximal (upper,right) boundaries</p>
<p>This is basically the way to construct the all the replicas of the original cell around it such that the most far distant point of the replicated cells is not closer than by Roff to any point (even the closest one) of the original cell.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t1</td><td>unit cell vector in the a direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t2</td><td>unit cell vector in the b direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t3</td><td>unit cell vector in the c direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g1</td><td>vector reciprocal to t1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2</td><td>vector reciprocal to t2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g3</td><td>vector reciprocal to t3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Roff</td><td>cutoff distance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">minb</td><td>is the triple containing the integer translations of the unit cell to form the minimal boundary of the super-cell </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">maxb</td><td>is the triple containing the integer translations of the unit cell to form the maximal boundary of the super-cell</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac62156086d498cad2f21ae68833c669a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcell::form_neibc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>neibc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cellx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>celly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cellz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Roff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Form the neighbor cells list</p>
<p>This function calculates serial indexes of the cells (neighbor cells) of the cells which are neighbor to the one with serial index <code> <a class="el" href="classliblibra_1_1libcell_1_1Cell.html">Cell</a> a is defined as neighbor to cell b if at least in one dimension (x,y or z) the cells (any same poins) are less then &lt;Roff&gt; apart Parameters &lt;cellx&gt;,&lt;celly&gt; and &lt;cellz&gt; give the size of the sub-cell in corresponding dimension. &lt;Nx&gt;,&lt;Ny&gt; and &lt;Nz&gt; - are maximal number of cells in corresponding dimension Serial indexes are stored in &lt;neibc&gt; variable</code></p>
<p><code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Index of the cell for which we want to construct neighbor cells list </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">neibc</td><td>Indices (serial) of the cells that are neighbor to the cell c </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nx</td><td>maximal number of cells in the a direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ny</td><td>maximal number of cells in the b direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nz</td><td>maximal number of cells in the c direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cellx</td><td>the size of the cell in a direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">celly</td><td>the size of the cell in b direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cellz</td><td>the size of the cell in c direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Roff</td><td>cutoff distance that is used to determine of the atoms are neighbor</td></tr>
  </table>
  </dd>
</dl>
<p></code></p>

</div>
</div>
<a class="anchor" id="a848fbe138eb92c9910b8b55c6974b31f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcell::make_nlist </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX3x3 &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cellx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>celly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cellz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Roff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; quartet &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>nlist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create neighbor list</p>
<p>Implement an improved Verlet list method (combination of Verlet list and linked cell list). Many ideas according to: Yao, Z.; Wang, J-S.; Liu, G-R. and Cheng, M "Improved neighbor list algorithm in molecular simulations using cell decomposition and data sorting method" Computer Physics Communications 2004, 161, 27-35</p>
<p>This function calculates the neighbor lists for all &lt;Nat&gt; atoms with original coordinates given by array &lt;r&gt; in simulation cell given by box &lt;H&gt; subject to periodic boundary conditions. The parameters &lt;maxa&gt;, &lt;maxb&gt; and &lt;maxc&gt; give the number of periodic translations of original simulation cell in each direction. They should be chosen such that all real atoms interact with all other atoms and images within &lt;Roff&gt; distance Parameters &lt;cellx&gt;, &lt;celly&gt;, &lt;cellz&gt; give the size of the sub-cell used to accelerate in computations and make them scale as O(NlogN) Final results will then be stored in &lt;nlist&gt; array</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Nat</td><td>The number of atoms in the system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>The pointer to the array containing the coordinates of all atoms </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">H</td><td>is the matrix describing the shape and size of the unit cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxa</td><td>The maximal number of periodic translation of the unit cell along a axis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxb</td><td>The maximal number of periodic translation of the unit cell along b axis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxc</td><td>The maximal number of periodic translation of the unit cell along c axis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cellx</td><td>The size of the sub-cells in x direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">celly</td><td>The size of the sub-cells in y direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cellz</td><td>The size of the sub-cells in z direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Roff</td><td>The cutoff distance which controls the formation of the neighbor list </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">nlist</td><td>Indices of the neighboring sub-cells for all sub-cells</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a14fa855e85f37cce89dc6db2450321aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcell::make_nlist_auto </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX3x3 &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cellx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>celly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cellz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Roff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; quartet &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>nlist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create neighbor list (no manual maximal translation parameters)</p>
<p>Implement improved Verlet list method (combination of Verlet list and linked cell list). Many ideas according to: Yao, Z.; Wang, J-S.; Liu, G-R. and Cheng, M "Improved neighbor list algorithm in molecular simulations using cell decomposition and data sorting method" Computer Physics Communications 2004, 161, 27-35</p>
<p>This function calculates the neighbor lists for all &lt;Nat&gt; atoms with original coordinates given by array &lt;r&gt; in simulation cell given by box &lt;H&gt; subject to periodic boundary conditions. The parameters &lt;maxa&gt;, &lt;maxb&gt; and &lt;maxc&gt; give the number of periodic translations of original simulation cell in each direction. In this version they are determined automatically from the shape of the simulation cell such that all real atoms interact with all other atoms and images within &lt;Roff&gt; distance Parameters &lt;cellx&gt;, &lt;celly&gt;, &lt;cellz&gt; give the size of the sub-cell used to accelerate in computations and make them scale as O(NlogN) Final results will then be stored in &lt;nlist&gt; array</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Nat</td><td>The number of atoms in the system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>The pointer to the array containing the coordinates of all atoms </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">H</td><td>is the matrix describing the shape and size of the unit cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cellx</td><td>The size of the sub-cells in x direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">celly</td><td>The size of the sub-cells in y direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cellz</td><td>The size of the sub-cells in z direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Roff</td><td>The cutoff distance which controls the formation of the neighbor list </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">nlist</td><td>Indices of the neighboring sub-cells for all sub-cells</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a95a19de389cce3568fee74420fdf4ed8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcell::max_vector </td>
          <td>(</td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>t3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finding the maximal-length vector</p>
<p>This function finds the maximal projections on X,Y and Z coordinate axes. In absolute value! in the box H = (t1,t2,t3)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t1</td><td>unit cell vector (a direction) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t2</td><td>unit cell vector (b direction) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t3</td><td>unit cell vector (c direction) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>the resulting vector containing the projections of the maximal-length vector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a00c86c62f5f1059e6d3d0d80bfa5722d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcell::serial_to_vector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mapping of a single integer index (serial) into 3 integers (vector)</p>
<p>This function calculates the indexes of projections &lt;nx&gt;, &lt;ny&gt;, &lt;nz&gt; of given cell (given by its serial index <code>) in the 3-D array of such cells. The array is rectangular. Indexing goes as: nx in [0, Nx] ny in [0, Ny] nz in [0, Nz] c &lt;&mdash;&gt; nx,ny,nz &lt;Nx&gt;,&lt;Ny&gt; and &lt;Nz&gt; - are maximal number of cells in corresponding dimension</code></p>
<p><code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>the serial index of the cell in the array of cells </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nx</td><td>maximal number of cell replicas in x dimension (along a vector, actually) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ny</td><td>maximal number of cell replicas in y dimension (along b vector, actually) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nz</td><td>maximal number of cell replicas in z dimension (along c vector, actually) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nx</td><td>the x (first) component of the integer translation vector for given cell </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ny</td><td>the y (second) component of the integer translation vector for given cell </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nz</td><td>the z (third) component of the integer translation vector for given cell</td></tr>
  </table>
  </dd>
</dl>
<p></code></p>

</div>
</div>
<a class="anchor" id="a9b88ab9278cb700d45d8519ff38a875f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcell::serial_to_vector_symm </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mapping of a single integer index (serial) into 3 integers (vector)</p>
<p>This function calculates the indexes of projections &lt;nx&gt;, &lt;ny&gt;, &lt;nz&gt; of given cell (given by its serial index <code>) in the 3-D array of such cells. The array is rectangular. Indexing goes as: nx in [-Nx, Nx] ny in [-Ny, Ny] nz in [-Nz, Nz] c &lt;&mdash;&gt; nx,ny,nz &lt;Nx&gt;,&lt;Ny&gt; and &lt;Nz&gt; - are maximal number of cells in corresponding dimension This function is similar to serial_to_vector functions, but is designed for symmetric range of nx,ny and nz</code></p>
<p><code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>the serial index of the cell in the array of cells </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nx</td><td>maximal number of cell replicas in x dimension (along a vector, actually) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ny</td><td>maximal number of cell replicas in y dimension (along b vector, actually) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nz</td><td>maximal number of cell replicas in z dimension (along c vector, actually) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nx</td><td>the x (first) component of the integer translation vector for given cell </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ny</td><td>the y (second) component of the integer translation vector for given cell </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nz</td><td>the z (third) component of the integer translation vector for given cell</td></tr>
  </table>
  </dd>
</dl>
<p></code></p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 25 2017 14:01:30 for Libra by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
