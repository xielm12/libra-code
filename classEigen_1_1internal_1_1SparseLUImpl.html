<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Libra: Eigen::internal::SparseLUImpl&lt; Scalar, Index &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Libra
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Eigen</b></li><li class="navelem"><a class="el" href="namespaceEigen_1_1internal.html">internal</a></li><li class="navelem"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classEigen_1_1internal_1_1SparseLUImpl-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Eigen::internal::SparseLUImpl&lt; Scalar, Index &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="SparseLUImpl_8h_source.html">SparseLUImpl.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad2d25473615285eee61f8589b6ce67e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2d25473615285eee61f8589b6ce67e1"></a>
typedef <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; Scalar, <br class="typebreak"/>
Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ScalarVector</b></td></tr>
<tr class="separator:ad2d25473615285eee61f8589b6ce67e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6882f6d6a0fe3f45295412a7a0ad8d5a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6882f6d6a0fe3f45295412a7a0ad8d5a"></a>
typedef <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; Scalar, <br class="typebreak"/>
Dynamic, Dynamic, ColMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ScalarMatrix</b></td></tr>
<tr class="separator:a6882f6d6a0fe3f45295412a7a0ad8d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e9194a60517e9a64b3e5bd55d76799"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34e9194a60517e9a64b3e5bd55d76799"></a>
typedef <a class="el" href="classEigen_1_1Map.html">Map</a>&lt; <a class="el" href="classEigen_1_1Matrix.html">ScalarMatrix</a>, <br class="typebreak"/>
0, <a class="el" href="classEigen_1_1OuterStride.html">OuterStride</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MappedMatrixBlock</b></td></tr>
<tr class="separator:a34e9194a60517e9a64b3e5bd55d76799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324c3b4f8c848d4d270cd7b5159a3d70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a324c3b4f8c848d4d270cd7b5159a3d70"></a>
typedef <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; Index, Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IndexVector</b></td></tr>
<tr class="separator:a324c3b4f8c848d4d270cd7b5159a3d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb84aa3fbc3bd0ece860288c6741907"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecb84aa3fbc3bd0ece860288c6741907"></a>
typedef ScalarVector::RealScalar&#160;</td><td class="memItemRight" valign="bottom"><b>RealScalar</b></td></tr>
<tr class="separator:aecb84aa3fbc3bd0ece860288c6741907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d9e7ba751fbee938e6a612af7c888f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90d9e7ba751fbee938e6a612af7c888f"></a>
typedef <a class="el" href="classEigen_1_1Ref.html">Ref</a>&lt; <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; Scalar, <br class="typebreak"/>
Dynamic, 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BlockScalarVector</b></td></tr>
<tr class="separator:a90d9e7ba751fbee938e6a612af7c888f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c9f460f2f75fc43fed1f73d597051f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8c9f460f2f75fc43fed1f73d597051f"></a>
typedef <a class="el" href="classEigen_1_1Ref.html">Ref</a>&lt; <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; Index, <br class="typebreak"/>
Dynamic, 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BlockIndexVector</b></td></tr>
<tr class="separator:af8c9f460f2f75fc43fed1f73d597051f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6eee895cb8f69c5c8d435a9f01efb1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6eee895cb8f69c5c8d435a9f01efb1c"></a>
typedef <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">LU_GlobalLU_t</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a>, <a class="el" href="classEigen_1_1Matrix.html">ScalarVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GlobalLU_t</b></td></tr>
<tr class="separator:ac6eee895cb8f69c5c8d435a9f01efb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95939b10d8743a788d340d41527eb261"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95939b10d8743a788d340d41527eb261"></a>
typedef <a class="el" href="classEigen_1_1SparseMatrix.html">SparseMatrix</a>&lt; Scalar, <br class="typebreak"/>
ColMajor, Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixType</b></td></tr>
<tr class="separator:a95939b10d8743a788d340d41527eb261"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad979a6954777def3d05ba2c0cfb596fd"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:ad979a6954777def3d05ba2c0cfb596fd"><td class="memTemplItemLeft" align="right" valign="top">Index&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#ad979a6954777def3d05ba2c0cfb596fd">expand</a> (VectorType &amp;vec, Index &amp;length, Index nbElts, Index keep_prev, Index &amp;num_expansions)</td></tr>
<tr class="separator:ad979a6954777def3d05ba2c0cfb596fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9945782ef14205cc9fe5d0723394ab9"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#af9945782ef14205cc9fe5d0723394ab9">memInit</a> (Index m, Index n, Index annz, Index lwork, Index fillratio, Index panel_size, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:af9945782ef14205cc9fe5d0723394ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate various working space for the numerical factorization phase.  <a href="#af9945782ef14205cc9fe5d0723394ab9">More...</a><br/></td></tr>
<tr class="separator:af9945782ef14205cc9fe5d0723394ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1a50133ee1ca25c7a23f0099dcaab8"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a8c1a50133ee1ca25c7a23f0099dcaab8"><td class="memTemplItemLeft" align="right" valign="top">Index&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#a8c1a50133ee1ca25c7a23f0099dcaab8">memXpand</a> (VectorType &amp;vec, Index &amp;maxlen, Index nbElts, MemType memtype, Index &amp;num_expansions)</td></tr>
<tr class="memdesc:a8c1a50133ee1ca25c7a23f0099dcaab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the existing storage.  <a href="#a8c1a50133ee1ca25c7a23f0099dcaab8">More...</a><br/></td></tr>
<tr class="separator:a8c1a50133ee1ca25c7a23f0099dcaab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0840b6b32610849ace18f86af6ada25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#ad0840b6b32610849ace18f86af6ada25">heap_relax_snode</a> (const Index n, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;et, const Index relax_columns, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;descendants, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;relax_end)</td></tr>
<tr class="memdesc:ad0840b6b32610849ace18f86af6ada25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify the initial relaxed supernodes.  <a href="#ad0840b6b32610849ace18f86af6ada25">More...</a><br/></td></tr>
<tr class="separator:ad0840b6b32610849ace18f86af6ada25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e432734e3c35cc52ca11e61942a8d4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#a4e432734e3c35cc52ca11e61942a8d4b">relax_snode</a> (const Index n, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;et, const Index relax_columns, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;descendants, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;relax_end)</td></tr>
<tr class="memdesc:a4e432734e3c35cc52ca11e61942a8d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify the initial relaxed supernodes.  <a href="#a4e432734e3c35cc52ca11e61942a8d4b">More...</a><br/></td></tr>
<tr class="separator:a4e432734e3c35cc52ca11e61942a8d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643bb06478c3008ff1060dcc5d0091ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a643bb06478c3008ff1060dcc5d0091ef"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><b>snode_dfs</b> (const Index jcol, const Index kcol, const <a class="el" href="classEigen_1_1SparseMatrix.html">MatrixType</a> &amp;mat, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;xprune, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;marker, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="separator:a643bb06478c3008ff1060dcc5d0091ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63a3bccd7f153cc5555a3e9b8677706"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad63a3bccd7f153cc5555a3e9b8677706"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><b>snode_bmod</b> (const Index jcol, const Index fsupc, <a class="el" href="classEigen_1_1Matrix.html">ScalarVector</a> &amp;dense, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="separator:ad63a3bccd7f153cc5555a3e9b8677706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691fafc0d103de24f5d9da43b6168179"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#a691fafc0d103de24f5d9da43b6168179">pivotL</a> (const Index jcol, const RealScalar &amp;diagpivotthresh, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;perm_r, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;iperm_c, Index &amp;pivrow, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:a691fafc0d103de24f5d9da43b6168179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the numerical pivotin on the current column of L, and the CDIV operation.  <a href="#a691fafc0d103de24f5d9da43b6168179">More...</a><br/></td></tr>
<tr class="separator:a691fafc0d103de24f5d9da43b6168179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7839502cf8aeb815e79d35629776d48"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac7839502cf8aeb815e79d35629776d48"></a>
template&lt;typename Traits &gt; </td></tr>
<tr class="memitem:ac7839502cf8aeb815e79d35629776d48"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dfs_kernel</b> (const Index jj, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;perm_r, Index &amp;nseg, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;panel_lsub, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;segrep, <a class="el" href="classEigen_1_1Ref.html">Ref</a>&lt; <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &gt; repfnz_col, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;xprune, <a class="el" href="classEigen_1_1Ref.html">Ref</a>&lt; <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &gt; marker, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;parent, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;xplore, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu, Index &amp;nextl_col, Index krow, Traits &amp;<a class="el" href="structEigen_1_1internal_1_1traits.html">traits</a>)</td></tr>
<tr class="separator:ac7839502cf8aeb815e79d35629776d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaeee6ff7667d743c96986081f62d751"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#aaaeee6ff7667d743c96986081f62d751">panel_dfs</a> (const Index m, const Index w, const Index jcol, <a class="el" href="classEigen_1_1SparseMatrix.html">MatrixType</a> &amp;A, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;perm_r, Index &amp;nseg, <a class="el" href="classEigen_1_1Matrix.html">ScalarVector</a> &amp;dense, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;panel_lsub, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;segrep, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;repfnz, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;xprune, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;marker, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;parent, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;xplore, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:aaaeee6ff7667d743c96986081f62d751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a symbolic factorization on a panel of columns [jcol, jcol+w)  <a href="#aaaeee6ff7667d743c96986081f62d751">More...</a><br/></td></tr>
<tr class="separator:aaaeee6ff7667d743c96986081f62d751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8fad25e9562c5231e81fe8ed61db16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#a7e8fad25e9562c5231e81fe8ed61db16">panel_bmod</a> (const Index m, const Index w, const Index jcol, const Index nseg, <a class="el" href="classEigen_1_1Matrix.html">ScalarVector</a> &amp;dense, <a class="el" href="classEigen_1_1Matrix.html">ScalarVector</a> &amp;tempv, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;segrep, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;repfnz, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:a7e8fad25e9562c5231e81fe8ed61db16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs numeric block updates (sup-panel) in topological order.  <a href="#a7e8fad25e9562c5231e81fe8ed61db16">More...</a><br/></td></tr>
<tr class="separator:a7e8fad25e9562c5231e81fe8ed61db16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08e94104581b16697bd7b5828cb8507"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#ab08e94104581b16697bd7b5828cb8507">column_dfs</a> (const Index m, const Index jcol, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;perm_r, Index maxsuper, Index &amp;nseg, <a class="el" href="classEigen_1_1Ref.html">BlockIndexVector</a> lsub_col, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;segrep, <a class="el" href="classEigen_1_1Ref.html">BlockIndexVector</a> repfnz, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;xprune, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;marker, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;parent, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;xplore, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:ab08e94104581b16697bd7b5828cb8507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a symbolic factorization on column jcol and decide the supernode boundary.  <a href="#ab08e94104581b16697bd7b5828cb8507">More...</a><br/></td></tr>
<tr class="separator:ab08e94104581b16697bd7b5828cb8507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0979f09ffe0983fdff318e3dbf2eef68"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#a0979f09ffe0983fdff318e3dbf2eef68">column_bmod</a> (const Index jcol, const Index nseg, <a class="el" href="classEigen_1_1Ref.html">BlockScalarVector</a> dense, <a class="el" href="classEigen_1_1Matrix.html">ScalarVector</a> &amp;tempv, <a class="el" href="classEigen_1_1Ref.html">BlockIndexVector</a> segrep, <a class="el" href="classEigen_1_1Ref.html">BlockIndexVector</a> repfnz, Index fpanelc, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:a0979f09ffe0983fdff318e3dbf2eef68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs numeric block updates (sup-col) in topological order.  <a href="#a0979f09ffe0983fdff318e3dbf2eef68">More...</a><br/></td></tr>
<tr class="separator:a0979f09ffe0983fdff318e3dbf2eef68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb30e5fc6e55e741fb091cc131a0835"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#a6cb30e5fc6e55e741fb091cc131a0835">copy_to_ucol</a> (const Index jcol, const Index nseg, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;segrep, <a class="el" href="classEigen_1_1Ref.html">BlockIndexVector</a> repfnz, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;perm_r, <a class="el" href="classEigen_1_1Ref.html">BlockScalarVector</a> dense, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:a6cb30e5fc6e55e741fb091cc131a0835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs numeric block updates (sup-col) in topological order.  <a href="#a6cb30e5fc6e55e741fb091cc131a0835">More...</a><br/></td></tr>
<tr class="separator:a6cb30e5fc6e55e741fb091cc131a0835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17e3d1176edfa0365f5de8928739bfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#aa17e3d1176edfa0365f5de8928739bfd">pruneL</a> (const Index jcol, const <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;perm_r, const Index pivrow, const Index nseg, const <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;segrep, <a class="el" href="classEigen_1_1Ref.html">BlockIndexVector</a> repfnz, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;xprune, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:aa17e3d1176edfa0365f5de8928739bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prunes the L-structure.  <a href="#aa17e3d1176edfa0365f5de8928739bfd">More...</a><br/></td></tr>
<tr class="separator:aa17e3d1176edfa0365f5de8928739bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056d27d2f8d025109c8176f319a7821e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a056d27d2f8d025109c8176f319a7821e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#a056d27d2f8d025109c8176f319a7821e">countnz</a> (const Index n, Index &amp;nnzL, Index &amp;nnzU, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:a056d27d2f8d025109c8176f319a7821e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count Nonzero elements in the factors. <br/></td></tr>
<tr class="separator:a056d27d2f8d025109c8176f319a7821e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a577417a1cfe48f1e051651dc7e015b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#a1a577417a1cfe48f1e051651dc7e015b">fixupL</a> (const Index n, const <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;perm_r, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:a1a577417a1cfe48f1e051651dc7e015b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix up the data storage lsub for L-subscripts.  <a href="#a1a577417a1cfe48f1e051651dc7e015b">More...</a><br/></td></tr>
<tr class="separator:a1a577417a1cfe48f1e051651dc7e015b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aeb52445d9b5f3ca9a6e74be2e7e42e12"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeb52445d9b5f3ca9a6e74be2e7e42e12"></a>
template&lt;typename , typename &gt; </td></tr>
<tr class="memitem:aeb52445d9b5f3ca9a6e74be2e7e42e12"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><b>column_dfs_traits</b></td></tr>
<tr class="separator:aeb52445d9b5f3ca9a6e74be2e7e42e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Scalar, typename Index&gt;<br/>
class Eigen::internal::SparseLUImpl&lt; Scalar, Index &gt;</h3>

<p>Base class for sparseLU </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0979f09ffe0983fdff318e3dbf2eef68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, Index &gt;::column_bmod </td>
          <td>(</td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Ref.html">BlockScalarVector</a>&#160;</td>
          <td class="paramname"><em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">ScalarVector</a> &amp;&#160;</td>
          <td class="paramname"><em>tempv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Ref.html">BlockIndexVector</a>&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Ref.html">BlockIndexVector</a>&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>fpanelc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;&#160;</td>
          <td class="paramname"><em>glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs numeric block updates (sup-col) in topological order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jcol</td><td>current column to update </td></tr>
    <tr><td class="paramname">nseg</td><td>Number of segments in the U part </td></tr>
    <tr><td class="paramname">dense</td><td>Store the full representation of the column </td></tr>
    <tr><td class="paramname">tempv</td><td>working array </td></tr>
    <tr><td class="paramname">segrep</td><td>segment representative ... </td></tr>
    <tr><td class="paramname">repfnz</td><td>??? First nonzero column in each row ??? ... </td></tr>
    <tr><td class="paramname">fpanelc</td><td>First column in the current panel </td></tr>
    <tr><td class="paramname">glu</td><td>Global <a class="el" href="classEigen_1_1LU.html">LU</a> data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 - successful return &gt; 0 - number of bytes allocated when run out of space </dd></dl>

</div>
</div>
<a class="anchor" id="ab08e94104581b16697bd7b5828cb8507"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, Index &gt;::column_dfs </td>
          <td>(</td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>maxsuper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Ref.html">BlockIndexVector</a>&#160;</td>
          <td class="paramname"><em>lsub_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Ref.html">BlockIndexVector</a>&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>xprune</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>xplore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;&#160;</td>
          <td class="paramname"><em>glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a symbolic factorization on column jcol and decide the supernode boundary. </p>
<p>A supernode representative is the last column of a supernode. The nonzeros in U[*,j] are segments that end at supernodes representatives. The routine returns a list of the supernodal representatives in topological order of the dfs that generates them. The location of the first nonzero in each supernodal segment (supernodal entry location) is also returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">m</td><td>number of rows in the matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">jcol</td><td>Current column </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">perm_r</td><td>Row permutation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxsuper</td><td>Maximum number of column allowed in a supernode </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">nseg</td><td>Number of segments in current U[*,j] - new segments appended </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lsub_col</td><td>defines the rhs vector to start the dfs </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">segrep</td><td>Segment representatives - new segments appended </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">repfnz</td><td>First nonzero location in each row </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">xprune</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">marker</td><td>marker[i] == jj, if i was visited during dfs of current column jj; </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parent</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">xplore</td><td>working array </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">glu</td><td>global <a class="el" href="classEigen_1_1LU.html">LU</a> data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success &gt; 0 number of bytes allocated when run out of space </dd></dl>

</div>
</div>
<a class="anchor" id="a6cb30e5fc6e55e741fb091cc131a0835"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, Index &gt;::copy_to_ucol </td>
          <td>(</td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Ref.html">BlockIndexVector</a>&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Ref.html">BlockScalarVector</a>&#160;</td>
          <td class="paramname"><em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;&#160;</td>
          <td class="paramname"><em>glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs numeric block updates (sup-col) in topological order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jcol</td><td>current column to update </td></tr>
    <tr><td class="paramname">nseg</td><td>Number of segments in the U part </td></tr>
    <tr><td class="paramname">segrep</td><td>segment representative ... </td></tr>
    <tr><td class="paramname">repfnz</td><td>First nonzero column in each row ... </td></tr>
    <tr><td class="paramname">perm_r</td><td>Row permutation </td></tr>
    <tr><td class="paramname">dense</td><td>Store the full representation of the column </td></tr>
    <tr><td class="paramname">glu</td><td>Global <a class="el" href="classEigen_1_1LU.html">LU</a> data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 - successful return &gt; 0 - number of bytes allocated when run out of space </dd></dl>

</div>
</div>
<a class="anchor" id="ad979a6954777def3d05ba2c0cfb596fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, Index &gt;::expand </td>
          <td>(</td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>nbElts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>keep_prev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&#160;</td>
          <td class="paramname"><em>num_expansions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Expand the existing storage to accomodate more fill-ins </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">vec</td><td>Valid pointer to the vector to allocate or expand </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">length</td><td>At input, contain the current length of the vector that is to be increased. At output, length of the newly allocated vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbElts</td><td>Current number of elements in the factors </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">keep_prev</td><td>1: use length and do not expand the vector; 0: compute new_len and expand </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">num_expansions</td><td>Number of times the memory has been expanded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a577417a1cfe48f1e051651dc7e015b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, Index &gt;::fixupL </td>
          <td>(</td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;&#160;</td>
          <td class="paramname"><em>glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fix up the data storage lsub for L-subscripts. </p>
<p>It removes the subscripts sets for structural pruning, and applies permutation to the remaining subscripts </p>

</div>
</div>
<a class="anchor" id="ad0840b6b32610849ace18f86af6ada25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, Index &gt;::heap_relax_snode </td>
          <td>(</td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>et</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>relax_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>descendants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>relax_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identify the initial relaxed supernodes. </p>
<p>This routine applied to a symmetric elimination tree. It assumes that the matrix has been reordered according to the postorder of the etree </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of columns </td></tr>
    <tr><td class="paramname">et</td><td>elimination tree </td></tr>
    <tr><td class="paramname">relax_columns</td><td>Maximum number of columns allowed in a relaxed snode </td></tr>
    <tr><td class="paramname">descendants</td><td>Number of descendants of each node in the etree </td></tr>
    <tr><td class="paramname">relax_end</td><td>last column in a supernode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af9945782ef14205cc9fe5d0723394ab9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, Index &gt;::memInit </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>annz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>fillratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>panel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;&#160;</td>
          <td class="paramname"><em>glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate various working space for the numerical factorization phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>number of rows of the input matrix </td></tr>
    <tr><td class="paramname">n</td><td>number of columns </td></tr>
    <tr><td class="paramname">annz</td><td>number of initial nonzeros in the matrix </td></tr>
    <tr><td class="paramname">lwork</td><td>if lwork=-1, this routine returns an estimated size of the required memory </td></tr>
    <tr><td class="paramname">glu</td><td>persistent data to facilitate multiple factors : will be deleted later ?? </td></tr>
    <tr><td class="paramname">fillratio</td><td>estimated ratio of fill in the factors </td></tr>
    <tr><td class="paramname">panel_size</td><td>Size of a panel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an estimated size of the required memory if lwork = -1; otherwise, return the size of actually allocated memory when allocation failed, and 0 on success </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Unlike <a class="el" href="classEigen_1_1SuperLU.html" title="A sparse direct LU factorization and solver based on the SuperLU library. ">SuperLU</a>, this routine does not support successive factorization with the same pattern and the same row permutation </dd></dl>

</div>
</div>
<a class="anchor" id="a8c1a50133ee1ca25c7a23f0099dcaab8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, Index &gt;::memXpand </td>
          <td>(</td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&#160;</td>
          <td class="paramname"><em>maxlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>nbElts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemType&#160;</td>
          <td class="paramname"><em>memtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&#160;</td>
          <td class="paramname"><em>num_expansions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expand the existing storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">vec</td><td>vector to expand </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">maxlen</td><td>On input, previous size of vec (Number of elements to copy ). on output, new size </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nbElts</td><td>current number of elements in the vector. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">memtype</td><td>Type of the element to expand </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num_expansions</td><td>Number of expansions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &gt; 0 size of the memory allocated so far </dd></dl>

</div>
</div>
<a class="anchor" id="a7e8fad25e9562c5231e81fe8ed61db16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, Index &gt;::panel_bmod </td>
          <td>(</td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">ScalarVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">ScalarVector</a> &amp;&#160;</td>
          <td class="paramname"><em>tempv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;&#160;</td>
          <td class="paramname"><em>glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs numeric block updates (sup-panel) in topological order. </p>
<p>Before entering this routine, the original nonzeros in the panel were already copied i nto the spa[m,w]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>number of rows in the matrix </td></tr>
    <tr><td class="paramname">w</td><td>Panel size </td></tr>
    <tr><td class="paramname">jcol</td><td>Starting column of the panel </td></tr>
    <tr><td class="paramname">nseg</td><td>Number of segments in the U part </td></tr>
    <tr><td class="paramname">dense</td><td>Store the full representation of the panel </td></tr>
    <tr><td class="paramname">tempv</td><td>working array </td></tr>
    <tr><td class="paramname">segrep</td><td>segment representative... first row in the segment </td></tr>
    <tr><td class="paramname">repfnz</td><td>First nonzero rows </td></tr>
    <tr><td class="paramname">glu</td><td>Global <a class="el" href="classEigen_1_1LU.html">LU</a> data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaaeee6ff7667d743c96986081f62d751"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, Index &gt;::panel_dfs </td>
          <td>(</td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1SparseMatrix.html">MatrixType</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">ScalarVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>panel_lsub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>xprune</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>xplore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;&#160;</td>
          <td class="paramname"><em>glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a symbolic factorization on a panel of columns [jcol, jcol+w) </p>
<p>A supernode representative is the last column of a supernode. The nonzeros in U[*,j] are segments that end at supernodes representatives</p>
<p>The routine returns a list of the supernodal representatives in topological order of the dfs that generates them. This list is a superset of the topological order of each individual column within the panel. The location of the first nonzero in each supernodal segment (supernodal entry location) is also returned. Each column has a separate list for this purpose.</p>
<p>Two markers arrays are used for dfs : marker[i] == jj, if i was visited during dfs of current column jj; marker1[i] &gt;= jcol, if i was visited by earlier columns in this panel;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of rows in the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Panel size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">jcol</td><td>Starting column of the panel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input matrix in column-major storage </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm_r</td><td>Row permutation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nseg</td><td>Number of U segments </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dense</td><td>Accumulate the column vectors of the panel </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">panel_lsub</td><td>Subscripts of the row in the panel </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">segrep</td><td>Segment representative i.e first nonzero row of each segment </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">repfnz</td><td>First nonzero location in each row </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xprune</td><td>The pruned elimination tree </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">marker</td><td>work vector </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parent</td><td>The elimination tree </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">xplore</td><td>work vector </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">glu</td><td>The global data structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a691fafc0d103de24f5d9da43b6168179"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, Index &gt;::pivotL </td>
          <td>(</td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>diagpivotthresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>iperm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&#160;</td>
          <td class="paramname"><em>pivrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;&#160;</td>
          <td class="paramname"><em>glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the numerical pivotin on the current column of L, and the CDIV operation. </p>
<p>Pivot policy : (1) Compute thresh = u * max_(i&gt;=j) abs(A_ij); (2) IF user specifies pivot row k and abs(A_kj) &gt;= thresh THEN pivot row = k; ELSE IF abs(A_jj) &gt;= thresh THEN pivot row = j; ELSE pivot row = m;</p>
<p>Note: If you absolutely want to use a given pivot order, then set u=0.0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">jcol</td><td>The current column of L </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">diagpivotthresh</td><td>diagonal pivoting threshold </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">perm_r</td><td>Row permutation (threshold pivoting) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iperm_c</td><td>column permutation - used to finf diagonal of Pc*A*Pc' </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pivrow</td><td>The pivot row </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">glu</td><td>Global <a class="el" href="classEigen_1_1LU.html">LU</a> data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, i &gt; 0 if U(i,i) is exactly zero </dd></dl>

</div>
</div>
<a class="anchor" id="aa17e3d1176edfa0365f5de8928739bfd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, Index &gt;::pruneL </td>
          <td>(</td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>pivrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Ref.html">BlockIndexVector</a>&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>xprune</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;&#160;</td>
          <td class="paramname"><em>glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prunes the L-structure. </p>
<p>It prunes the L-structure of supernodes whose L-structure contains the current pivot row "pivrow"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">jcol</td><td>The current column of L </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm_r</td><td>Row permutation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pivrow</td><td>The pivot row </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nseg</td><td>Number of segments </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">segrep</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">repfnz</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xprune</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">glu</td><td>Global <a class="el" href="classEigen_1_1LU.html">LU</a> data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e432734e3c35cc52ca11e61942a8d4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, Index &gt;::relax_snode </td>
          <td>(</td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>et</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>relax_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>descendants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>relax_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identify the initial relaxed supernodes. </p>
<p>This routine is applied to a column elimination tree. It assumes that the matrix has been reordered according to the postorder of the etree </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of columns </td></tr>
    <tr><td class="paramname">et</td><td>elimination tree </td></tr>
    <tr><td class="paramname">relax_columns</td><td>Maximum number of columns allowed in a relaxed snode </td></tr>
    <tr><td class="paramname">descendants</td><td>Number of descendants of each node in the etree </td></tr>
    <tr><td class="paramname">relax_end</td><td>last column in a supernode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/travis/build/Quantum-Dynamics-Hub/libra-code/src/math_meigen/Eigen/src/SparseLU/<a class="el" href="SparseLUImpl_8h_source.html">SparseLUImpl.h</a></li>
<li>/home/travis/build/Quantum-Dynamics-Hub/libra-code/src/math_meigen/Eigen/src/SparseLU/<a class="el" href="SparseLU__column__bmod_8h_source.html">SparseLU_column_bmod.h</a></li>
<li>/home/travis/build/Quantum-Dynamics-Hub/libra-code/src/math_meigen/Eigen/src/SparseLU/<a class="el" href="SparseLU__column__dfs_8h_source.html">SparseLU_column_dfs.h</a></li>
<li>/home/travis/build/Quantum-Dynamics-Hub/libra-code/src/math_meigen/Eigen/src/SparseLU/<a class="el" href="SparseLU__copy__to__ucol_8h_source.html">SparseLU_copy_to_ucol.h</a></li>
<li>/home/travis/build/Quantum-Dynamics-Hub/libra-code/src/math_meigen/Eigen/src/SparseLU/<a class="el" href="SparseLU__heap__relax__snode_8h_source.html">SparseLU_heap_relax_snode.h</a></li>
<li>/home/travis/build/Quantum-Dynamics-Hub/libra-code/src/math_meigen/Eigen/src/SparseLU/<a class="el" href="SparseLU__Memory_8h_source.html">SparseLU_Memory.h</a></li>
<li>/home/travis/build/Quantum-Dynamics-Hub/libra-code/src/math_meigen/Eigen/src/SparseLU/<a class="el" href="SparseLU__panel__bmod_8h_source.html">SparseLU_panel_bmod.h</a></li>
<li>/home/travis/build/Quantum-Dynamics-Hub/libra-code/src/math_meigen/Eigen/src/SparseLU/<a class="el" href="SparseLU__panel__dfs_8h_source.html">SparseLU_panel_dfs.h</a></li>
<li>/home/travis/build/Quantum-Dynamics-Hub/libra-code/src/math_meigen/Eigen/src/SparseLU/<a class="el" href="SparseLU__pivotL_8h_source.html">SparseLU_pivotL.h</a></li>
<li>/home/travis/build/Quantum-Dynamics-Hub/libra-code/src/math_meigen/Eigen/src/SparseLU/<a class="el" href="SparseLU__pruneL_8h_source.html">SparseLU_pruneL.h</a></li>
<li>/home/travis/build/Quantum-Dynamics-Hub/libra-code/src/math_meigen/Eigen/src/SparseLU/<a class="el" href="SparseLU__relax__snode_8h_source.html">SparseLU_relax_snode.h</a></li>
<li>/home/travis/build/Quantum-Dynamics-Hub/libra-code/src/math_meigen/Eigen/src/SparseLU/<a class="el" href="SparseLU__Utils_8h_source.html">SparseLU_Utils.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 25 2017 14:01:25 for Libra by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
