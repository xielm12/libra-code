<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Libra: liblibra::libdyn::libensemble::Ensemble Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Libra
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceliblibra.html">liblibra</a></li><li class="navelem"><a class="el" href="namespaceliblibra_1_1libdyn.html">libdyn</a></li><li class="navelem"><a class="el" href="namespaceliblibra_1_1libdyn_1_1libensemble.html">libensemble</a></li><li class="navelem"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html">Ensemble</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">liblibra::libdyn::libensemble::Ensemble Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad4038d629664f052dd5e7dadf8c6b255"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#ad4038d629664f052dd5e7dadf8c6b255">ham_set_ham</a> (int i, std::string opt, int mopt)</td></tr>
<tr class="separator:ad4038d629664f052dd5e7dadf8c6b255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b8dbf105a4b21761fa3123640f1d9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a20b8dbf105a4b21761fa3123640f1d9b">ham_set_ham</a> (std::string opt, int mopt)</td></tr>
<tr class="separator:a20b8dbf105a4b21761fa3123640f1d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e952b28e2a71badaa20077bdc20ee3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#ad0e952b28e2a71badaa20077bdc20ee3">ham_set_ham</a> (int i, <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> &amp;_ham)</td></tr>
<tr class="separator:ad0e952b28e2a71badaa20077bdc20ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34e8375767a0d3b8cd95a075f0ff288"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#aa34e8375767a0d3b8cd95a075f0ff288">ham_set_rep</a> (int i, int _rep)</td></tr>
<tr class="separator:aa34e8375767a0d3b8cd95a075f0ff288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4418ed79dbe9986615d9ffb353381d4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a4418ed79dbe9986615d9ffb353381d4c">ham_set_rep</a> (int _rep)</td></tr>
<tr class="separator:a4418ed79dbe9986615d9ffb353381d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba66e4fa7312434ebdf99651359ac794"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#aba66e4fa7312434ebdf99651359ac794">ham_set_params</a> (int i, vector&lt; double &gt; &amp;params_)</td></tr>
<tr class="separator:aba66e4fa7312434ebdf99651359ac794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2b6d3800f35d47478737b0e9d61f80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a3f2b6d3800f35d47478737b0e9d61f80">ham_set_params</a> (int i, boost::python::list params_)</td></tr>
<tr class="separator:a3f2b6d3800f35d47478737b0e9d61f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02c1d6ea0a8e847e1eca016e13a4c68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#af02c1d6ea0a8e847e1eca016e13a4c68">ham_set_params</a> (vector&lt; double &gt; &amp;params_)</td></tr>
<tr class="separator:af02c1d6ea0a8e847e1eca016e13a4c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7575555bebf5e825b7c1794c59956892"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a7575555bebf5e825b7c1794c59956892">ham_set_params</a> (boost::python::list params_)</td></tr>
<tr class="separator:a7575555bebf5e825b7c1794c59956892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23ba6c47c87a5a9413e475c6586f0c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#aa23ba6c47c87a5a9413e475c6586f0c6">ham_set_v</a> (int i, vector&lt; double &gt; &amp;v)</td></tr>
<tr class="separator:aa23ba6c47c87a5a9413e475c6586f0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9336f0068ff33dc2dc7be2dc88b02cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#aa9336f0068ff33dc2dc7be2dc88b02cc">ham_set_v</a> (int i, boost::python::list v)</td></tr>
<tr class="separator:aa9336f0068ff33dc2dc7be2dc88b02cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ec3e082e197740f89838e4116ac38e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a22ec3e082e197740f89838e4116ac38e">ham_set_v</a> ()</td></tr>
<tr class="separator:a22ec3e082e197740f89838e4116ac38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d05e38a0837b21f91c7c5675590abe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#aa4d05e38a0837b21f91c7c5675590abe">ham_set_q</a> (int i, vector&lt; double &gt; &amp;v)</td></tr>
<tr class="separator:aa4d05e38a0837b21f91c7c5675590abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa011934efea7ec00e4945ba9e503cde4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#aa011934efea7ec00e4945ba9e503cde4">ham_set_q</a> (int i, boost::python::list v)</td></tr>
<tr class="separator:aa011934efea7ec00e4945ba9e503cde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8606909df8193e8231cb0b23abb9ae0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a8606909df8193e8231cb0b23abb9ae0e">ham_compute</a> (int i)</td></tr>
<tr class="separator:a8606909df8193e8231cb0b23abb9ae0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa8117654aba719917444b6f4f4f048"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#acfa8117654aba719917444b6f4f4f048">ham_compute_diabatic</a> (int i)</td></tr>
<tr class="separator:acfa8117654aba719917444b6f4f4f048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaca9f19b5781dd2ace9e20fa0821892"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#afaca9f19b5781dd2ace9e20fa0821892">ham_compute_adiabatic</a> (int i)</td></tr>
<tr class="separator:afaca9f19b5781dd2ace9e20fa0821892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58962a1da20592f6e328d7632339569e"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a58962a1da20592f6e328d7632339569e">ham_H</a> (int traj, int i, int j)</td></tr>
<tr class="separator:a58962a1da20592f6e328d7632339569e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739e8cd3be68ed639cdedc0db9f19e58"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a739e8cd3be68ed639cdedc0db9f19e58">ham_dHdq</a> (int traj, int i, int j, int n)</td></tr>
<tr class="separator:a739e8cd3be68ed639cdedc0db9f19e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154fa6165b3e78c05338866325926299"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a154fa6165b3e78c05338866325926299">ham_D</a> (int traj, int i, int j, int n)</td></tr>
<tr class="separator:a154fa6165b3e78c05338866325926299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f2f006bbf438a8176c4983c5f13679"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a56f2f006bbf438a8176c4983c5f13679">ham_nac</a> (int traj, int i, int j)</td></tr>
<tr class="separator:a56f2f006bbf438a8176c4983c5f13679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e1d7846bbaf25c32482924e3d9d499"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a80e1d7846bbaf25c32482924e3d9d499">ham_Hvib</a> (int traj, int i, int j)</td></tr>
<tr class="separator:a80e1d7846bbaf25c32482924e3d9d499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa8f75d6f65512f385ad571ebb7422f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#acfa8f75d6f65512f385ad571ebb7422f">el_propagate_electronic</a> (int i, double dt)</td></tr>
<tr class="separator:acfa8f75d6f65512f385ad571ebb7422f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12403db952975fd8ddc5d8ae93f4eec0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a12403db952975fd8ddc5d8ae93f4eec0">el_propagate_electronic</a> (double dt)</td></tr>
<tr class="separator:a12403db952975fd8ddc5d8ae93f4eec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240787054ec83cd02ce6007606ec5666"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a240787054ec83cd02ce6007606ec5666">mol_propagate_p</a> (int i, double dt)</td></tr>
<tr class="separator:a240787054ec83cd02ce6007606ec5666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd7548027d5dbf95f55e37098b02b26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#abfd7548027d5dbf95f55e37098b02b26">mol_propagate_p</a> (double dt)</td></tr>
<tr class="separator:abfd7548027d5dbf95f55e37098b02b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1085067dc164672b64624a576eb87673"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a1085067dc164672b64624a576eb87673">mol_propagate_q</a> (int i, double dt)</td></tr>
<tr class="separator:a1085067dc164672b64624a576eb87673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d15c7ed6d862cb0e09e0e307cbd98a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a82d15c7ed6d862cb0e09e0e307cbd98a">mol_propagate_q</a> (double dt)</td></tr>
<tr class="separator:a82d15c7ed6d862cb0e09e0e307cbd98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa038b944ed3429738c4870f83a97ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#aaaa038b944ed3429738c4870f83a97ee">_init</a> (int, int, int)</td></tr>
<tr class="separator:aaaa038b944ed3429738c4870f83a97ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76144e2df88ff35af62efe2f08066dc8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a76144e2df88ff35af62efe2f08066dc8">Ensemble</a> (int, int, int)</td></tr>
<tr class="separator:a76144e2df88ff35af62efe2f08066dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6907ff76e223e539e491c056bb2f8e18"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a6907ff76e223e539e491c056bb2f8e18">~Ensemble</a> ()</td></tr>
<tr class="separator:a6907ff76e223e539e491c056bb2f8e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd76a66b4e9ece79c598be57f0a81b2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#abd76a66b4e9ece79c598be57f0a81b2e">se_pop</a> (vector&lt; double &gt; &amp;, double, double)</td></tr>
<tr class="separator:abd76a66b4e9ece79c598be57f0a81b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e7c411ac53e9308b0c26a45da1a685"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a90e7c411ac53e9308b0c26a45da1a685">se_pop</a> (vector&lt; double &gt; &amp;)</td></tr>
<tr class="separator:a90e7c411ac53e9308b0c26a45da1a685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429a9ea2294f6f2e9bbab13b39a20ba3"><td class="memItemLeft" align="right" valign="top">boost::python::list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a429a9ea2294f6f2e9bbab13b39a20ba3">se_pop</a> (double, double)</td></tr>
<tr class="separator:a429a9ea2294f6f2e9bbab13b39a20ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac946398aaef7bbb91957a28844dbace3"><td class="memItemLeft" align="right" valign="top">boost::python::list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#ac946398aaef7bbb91957a28844dbace3">se_pop</a> ()</td></tr>
<tr class="separator:ac946398aaef7bbb91957a28844dbace3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1f63c67b86b5d11ed19b80f20578a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#aed1f63c67b86b5d11ed19b80f20578a3">sh_pop</a> (vector&lt; double &gt; &amp;, double, double)</td></tr>
<tr class="separator:aed1f63c67b86b5d11ed19b80f20578a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61dc0755adec6f7f81e6c1d03e1d4593"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a61dc0755adec6f7f81e6c1d03e1d4593">sh_pop</a> (vector&lt; double &gt; &amp;)</td></tr>
<tr class="separator:a61dc0755adec6f7f81e6c1d03e1d4593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117952cbe0dd1ad8127b6c6453a5ddf4"><td class="memItemLeft" align="right" valign="top">boost::python::list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a117952cbe0dd1ad8127b6c6453a5ddf4">sh_pop</a> (double, double)</td></tr>
<tr class="separator:a117952cbe0dd1ad8127b6c6453a5ddf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af858c6dc564f34ef42e3ad06d25efe01"><td class="memItemLeft" align="right" valign="top">boost::python::list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#af858c6dc564f34ef42e3ad06d25efe01">sh_pop</a> ()</td></tr>
<tr class="separator:af858c6dc564f34ef42e3ad06d25efe01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93448fbb256f701e87186ff8ab28259f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a93448fbb256f701e87186ff8ab28259f">sh_pop1</a> (vector&lt; double &gt; &amp;, double, double)</td></tr>
<tr class="separator:a93448fbb256f701e87186ff8ab28259f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66b6c61ad9f9381964b6410b846d4d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#ac66b6c61ad9f9381964b6410b846d4d7">sh_pop1</a> (vector&lt; double &gt; &amp;)</td></tr>
<tr class="separator:ac66b6c61ad9f9381964b6410b846d4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc83bae567c3d94846fa3fcd3561b49"><td class="memItemLeft" align="right" valign="top">boost::python::list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a5bc83bae567c3d94846fa3fcd3561b49">sh_pop1</a> (double, double)</td></tr>
<tr class="separator:a5bc83bae567c3d94846fa3fcd3561b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2cf79e01561ee906870b035a91c98d"><td class="memItemLeft" align="right" valign="top">boost::python::list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#acc2cf79e01561ee906870b035a91c98d">sh_pop1</a> ()</td></tr>
<tr class="separator:acc2cf79e01561ee906870b035a91c98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bce68d307491607d2263fcc94a7929a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a0bce68d307491607d2263fcc94a7929a">print_map</a> (std::string prefix, double Xmin, double Xmax, double dx, double Ymin, double Ymax, double dy, int snap)</td></tr>
<tr class="separator:a0bce68d307491607d2263fcc94a7929a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499e6010b7c13f0c0c06cb0270d22120"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a499e6010b7c13f0c0c06cb0270d22120">integral_flux</a> (vector&lt; vector&lt; double &gt; &gt; &amp;Int_flx, double Xmin, double Xmax, double dx, double Ymin, double Ymax, double dy)</td></tr>
<tr class="separator:a499e6010b7c13f0c0c06cb0270d22120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ef14c7bcc766f8c47bfd1f1f0122e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#ab0ef14c7bcc766f8c47bfd1f1f0122e7">compute_averages</a> ()</td></tr>
<tr class="separator:ab0ef14c7bcc766f8c47bfd1f1f0122e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a6937dabc774114a52fbb423dedb3eb63"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a6937dabc774114a52fbb423dedb3eb63">ntraj</a></td></tr>
<tr class="memdesc:a6937dabc774114a52fbb423dedb3eb63"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html">Ensemble</a> class that is designed to propagate many trajectories (entangled or independent) at once.  <a href="#a6937dabc774114a52fbb423dedb3eb63">More...</a><br/></td></tr>
<tr class="separator:a6937dabc774114a52fbb423dedb3eb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8733436eb7753a1916a2ca9499d5e09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8733436eb7753a1916a2ca9499d5e09"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#ae8733436eb7753a1916a2ca9499d5e09">nnucl</a></td></tr>
<tr class="memdesc:ae8733436eb7753a1916a2ca9499d5e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of nuclear degrees of freedom <br/></td></tr>
<tr class="separator:ae8733436eb7753a1916a2ca9499d5e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad988929644367a36bc9d79cfe4ae0faf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad988929644367a36bc9d79cfe4ae0faf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#ad988929644367a36bc9d79cfe4ae0faf">nelec</a></td></tr>
<tr class="memdesc:ad988929644367a36bc9d79cfe4ae0faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of electronic DOFs <br/></td></tr>
<tr class="separator:ad988929644367a36bc9d79cfe4ae0faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4eb9da201a51254e92abce56eacca8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c4eb9da201a51254e92abce56eacca8"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a8c4eb9da201a51254e92abce56eacca8">is_active</a></td></tr>
<tr class="memdesc:a8c4eb9da201a51254e92abce56eacca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag stating if the i-th trajectory is active, if not - it is assumed to be fixed: no integration is applied <br/></td></tr>
<tr class="separator:a8c4eb9da201a51254e92abce56eacca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f4afc87a2903a1a6796761d2cf2701"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32f4afc87a2903a1a6796761d2cf2701"></a>
vector&lt; <a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a32f4afc87a2903a1a6796761d2cf2701">mol</a></td></tr>
<tr class="memdesc:a32f4afc87a2903a1a6796761d2cf2701"><td class="mdescLeft">&#160;</td><td class="mdescRight">nuclear subsystems <br/></td></tr>
<tr class="separator:a32f4afc87a2903a1a6796761d2cf2701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac003ce182b161bc51b32b3ffb56570d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac003ce182b161bc51b32b3ffb56570d6"></a>
vector&lt; <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#ac003ce182b161bc51b32b3ffb56570d6">el</a></td></tr>
<tr class="memdesc:ac003ce182b161bc51b32b3ffb56570d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">electronic subsystems <br/></td></tr>
<tr class="separator:ac003ce182b161bc51b32b3ffb56570d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4386ca0743baeead753f36df53df5c91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4386ca0743baeead753f36df53df5c91"></a>
vector&lt; <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html#a4386ca0743baeead753f36df53df5c91">ham</a></td></tr>
<tr class="memdesc:a4386ca0743baeead753f36df53df5c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hamiltonian "handlers" - unique for each copy. <br/></td></tr>
<tr class="separator:a4386ca0743baeead753f36df53df5c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a76144e2df88ff35af62efe2f08066dc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">liblibra::libdyn::libensemble::Ensemble::Ensemble </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_ntraj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_nstates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_nnucl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor with parameters</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_ntraj</td><td>The number of the trajectories of the ensemble </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_nstates</td><td>The number of electronic DOF (states) for each trajectoriy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_nnucl</td><td>The number of nuclear DOF for each trajectory</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6907ff76e223e539e491c056bb2f8e18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">liblibra::libdyn::libensemble::Ensemble::~Ensemble </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor</p>
<p>Doesn't do anything</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aaaa038b944ed3429738c4870f83a97ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::_init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_ntraj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_nelec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_nnucl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html">Ensemble</a> object initializer</p>
<p>Allocate memory for an ensemble of ntraj trajectories, with all electronic components represented in a basis of nstates electronic state and with nuclear component having the dimensionality of nnucl</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_ntraj</td><td>The number of trajectories in the ensemble </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_nelec</td><td>The number of electronic (quantum) states for each trajectory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_nnucl</td><td>The number of nuclear DOF for each trajectory</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0ef14c7bcc766f8c47bfd1f1f0122e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::compute_averages </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computing the ensemble-averaged value. Inactive now.</p>

</div>
</div>
<a class="anchor" id="acfa8f75d6f65512f385ad571ebb7422f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::el_propagate_electronic </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Propagate electronic DOF for a given trajectory</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Index of the trajectory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Integration time step (integration duration)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12403db952975fd8ddc5d8ae93f4eec0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::el_propagate_electronic </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Propagate electronic DOF for all trajectories</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Integration time step (integration duration)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8606909df8193e8231cb0b23abb9ae0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::ham_compute </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform actual Hamiltonian computations for the given trajectory</p>
<p>The computations of either diabatiatic or adiabatic or both Hamiltonians are invoked, depending on the representation set up for this Hamiltonian and on the state of the computations of such Hamiltonians (so, if no change of position/velocity has been made since the last computation of given Hamiltonian, no actually computations will be carryied out, not to do usefull work). Also, computations of adiabatic Hamiltonians (if adiabatic representation is set up) may call computation of the diabatic Hamiltonians, since they may be required. On the contrary, if the diabatic Hamiltonian is selected, the adiabatic Hamiltonian is not updated.</p>
<p>Note, that just updating momenta and positions will not lead to automatic recomputation of the Hamiltonians and derivatives</p>

</div>
</div>
<a class="anchor" id="afaca9f19b5781dd2ace9e20fa0821892"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::ham_compute_adiabatic </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform actual Hamiltonian computations (only adiabatic) for the given trajectory</p>
<p>The computations of adiabatiatic Hamiltonian is invoked, depending on the representation set up for this Hamiltonian and on the state of the computations of such Hamiltonian (so, if no change of position/velocity has been made since the last computation of given Hamiltonian, no actually computations will be carryied out, not to do usefull work).</p>
<p>Note, that just updating momenta and positions will not lead to automatic recomputation of the Hamiltonians and derivatives</p>

</div>
</div>
<a class="anchor" id="acfa8117654aba719917444b6f4f4f048"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::ham_compute_diabatic </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform actual Hamiltonian computations (only diabatic) for the given trajectory</p>
<p>The computations of either diabatiatic Hamiltonian is invoked, depending on the representation set up for this Hamiltonian and on the state of the computations of such Hamiltonian (so, if no change of position/velocity has been made since the last computation of given Hamiltonian, no actually computations will be carryied out, not to do usefull work).</p>
<p>Note, that just updating momenta and positions will not lead to automatic recomputation of the Hamiltonians and derivatives</p>

</div>
</div>
<a class="anchor" id="a154fa6165b3e78c05338866325926299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; liblibra::libdyn::libensemble::Ensemble::ham_D </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>traj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the derivative coupling w.r.t. nuclear DOF for given trajectory</p>
<p>The returned coupling depends on the selected representation - can be either diabatic or adiabatic. This function does not invoke actual computation - it only returns whatever exists in the internal variables.</p>
<p>D = &lt;i|d/dR_n|j&gt;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">traj</td><td>Index of the trajectory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index of electronic state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>index of electronic state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index of nuclear DOF w.r.t. which the coupling is computed</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a739e8cd3be68ed639cdedc0db9f19e58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; liblibra::libdyn::libensemble::Ensemble::ham_dHdq </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>traj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the derivative of electronic Hamiltonian w.r.t. nuclear DOF for given trajectory</p>
<p>The returned Hamiltonian depends on the selected representation - can be either diabatic or adiabatic. This function does not invoke actual computation - it only returns whatever exists in the internal variables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">traj</td><td>Index of the trajectory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index of electronic state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>index of electronic state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index of nuclear DOF w.r.t. which the differentiation is performed</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a58962a1da20592f6e328d7632339569e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; liblibra::libdyn::libensemble::Ensemble::ham_H </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>traj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return electronic Hamiltonian for given trajectory</p>
<p>The returned Hamiltonian depends on the selected representation - can be either diabatic or adiabatic. This function does not invoke actual computation - it only returns whatever exists in the internal variables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">traj</td><td>Index of the trajectory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index of electronic state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>index of electronic state</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80e1d7846bbaf25c32482924e3d9d499"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; liblibra::libdyn::libensemble::Ensemble::ham_Hvib </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>traj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the vibronic Hamiltonian for given trajectory</p>
<p>The returned Hamiltonian depends on the selected representation - can be either diabatic or adiabatic. This function does not invoke actual computation - it only returns whatever exists in the internal variables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">traj</td><td>Index of the trajectory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index of electronic state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>index of electronic state</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a56f2f006bbf438a8176c4983c5f13679"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; liblibra::libdyn::libensemble::Ensemble::ham_nac </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>traj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the nonadiabatic coupling for given trajectory</p>
<p>The returned coupling depends on the selected representation - can be either diabatic or adiabatic. This function does not invoke actual computation - it only returns whatever exists in the internal variables.</p>
<p>nac = sum_n { dR_n/dt * &lt;i|d/dR_n|j&gt; }</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">traj</td><td>Index of the trajectory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index of electronic state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>index of electronic state</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4038d629664f052dd5e7dadf8c6b255"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::ham_set_ham </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mopt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set Hamiltonian for the given trajectory</p>
<p>This function creates a new Hamiltonian internally. So far, works only for model Hamiltonians.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Is the index of the trajectory for which we setup the Hamiltonian </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opt</td><td>is the option to select the type of Hamiltonian. So far, can use only opt = "model" to create an array of model Hamiltonians </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mopt</td><td>The option to select the type of model Hamiltonian when creating the array of such Hamiltonians.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20b8dbf105a4b21761fa3123640f1d9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::ham_set_ham </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mopt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set Hamiltonians for all trajectories</p>
<p>This function creates a new Hamiltonians internally. So far, works only for model Hamiltonians.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">opt</td><td>is the option to select the type of Hamiltonian. So far, can use only opt = "model" to create an array of model Hamiltonians </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mopt</td><td>The option to select the type of model Hamiltonian when creating the array of such Hamiltonians.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0e952b28e2a71badaa20077bdc20ee3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::ham_set_ham </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> &amp;&#160;</td>
          <td class="paramname"><em>_ham</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set Hamiltonian for the given trajectory</p>
<p>This function binds the external Hamiltonian (or derived) object to the one stored and used internally. This is the pointer assignment, so eventually, both objects (their pointers) point to the same address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Is the index of the trajectory for which we setup the Hamiltonian </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_ham</td><td>The external object, which can be modified outside, but will still affect the <a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html">Ensemble</a> computations</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba66e4fa7312434ebdf99651359ac794"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::ham_set_params </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>params_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the parameters of the Hamiltonian associated with a given trajectory</p>
<p>So far, the model Hamiltonians are implied </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Is the index of the trajectory for which we setup Hamiltonian's parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params_</td><td>The vector of double-valued parameters to feed into the Hamiltonian</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f2b6d3800f35d47478737b0e9d61f80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::ham_set_params </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::python::list&#160;</td>
          <td class="paramname"><em>params_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the parameters of the Hamiltonian associated with a given trajectory (Python-friendly)</p>
<p>So far, the model Hamiltonians are implied </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Is the index of the trajectory for which we setup Hamiltonian's parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params_</td><td>The list of parameters (could be of different types) to feed into the Hamiltonian</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af02c1d6ea0a8e847e1eca016e13a4c68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::ham_set_params </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>params_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the parameters of the Hamiltonian associated with all trajectories in the ensemble</p>
<p>So far, the model Hamiltonians are implied </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params_</td><td>The vector of double-valued parameters to feed into the Hamiltonian</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7575555bebf5e825b7c1794c59956892"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::ham_set_params </td>
          <td>(</td>
          <td class="paramtype">boost::python::list&#160;</td>
          <td class="paramname"><em>params_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the parameters of the Hamiltonian associated with all trajectories in the ensemble (Python-friendly)</p>
<p>So far, the model Hamiltonians are implied </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params_</td><td>The list of parameters (could be of different types) to feed into the Hamiltonian</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4d05e38a0837b21f91c7c5675590abe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::ham_set_q </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update Hamiltonian coordinates (all are real-valued scalars)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Is the index of the trajectory for which we setup Hamiltonian's coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The vector of real-valued coordinates to be used for Hamiltonian calculations.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa011934efea7ec00e4945ba9e503cde4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::ham_set_q </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::python::list&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update Hamiltonian coordinates (all are real-valued scalars - the components of the Python list) - Python-friendly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Is the index of the trajectory for which we setup Hamiltonian's coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The list of real-valued coordinates to be used for Hamiltonian calculations.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa34e8375767a0d3b8cd95a075f0ff288"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::ham_set_rep </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_rep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a representation for given trajectory</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Is the index of the trajectory for which we setup the representation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_rep</td><td>The representation. Possible options: 0 (for diabatic) and 1 (for adiabatic)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4418ed79dbe9986615d9ffb353381d4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::ham_set_rep </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_rep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a representation for all trajectories in the ensemble</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rep</td><td>The representation. Possible options: 0 (for diabatic) and 1 (for adiabatic)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa23ba6c47c87a5a9413e475c6586f0c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::ham_set_v </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update Hamiltonian velocities (all are real-valued scalars)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Is the index of the trajectory for which we setup Hamiltonian's velocities </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The vector of real-valued velocities to be used for Hamiltonian calculations.</td></tr>
  </table>
  </dd>
</dl>
<p>The velocities are only needed for vibronic Hamiltonian (adiabatic representation) calculations. Otherwise, they are not used.</p>

</div>
</div>
<a class="anchor" id="aa9336f0068ff33dc2dc7be2dc88b02cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::ham_set_v </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::python::list&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update Hamiltonian velocities (all are real-valued scalars -the components of Python list) - Python-friendly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Is the index of the trajectory for which we setup Hamiltonian's velocities </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The vector of real-valued velocities to be used for Hamiltonian calculations.</td></tr>
  </table>
  </dd>
</dl>
<p>The velocities are only needed for vibronic Hamiltonian (adiabatic representation) calculations. Otherwise, they are not used.</p>

</div>
</div>
<a class="anchor" id="a22ec3e082e197740f89838e4116ac38e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::ham_set_v </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update Hamiltonian velocities for all trajectories</p>
<p>The velocities are computed using the nuclear momenta (extracted from internally-stored mol object) and the masses of all DOFs, also internally-stored in the mol object.</p>
<p>The velocities are only needed for vibronic Hamiltonian (adiabatic representation) calculations. Otherwise, they are not used.</p>

</div>
</div>
<a class="anchor" id="a499e6010b7c13f0c0c06cb0270d22120"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::integral_flux </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>Int_flx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Xmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Xmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Ymin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Ymax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>for 2D projections on XY plane. Inactive now.</p>

</div>
</div>
<a class="anchor" id="a240787054ec83cd02ce6007606ec5666"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::mol_propagate_p </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Propagate nuclear momenta for given trajectory</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Index of the trajectory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Integration time step (integration duration)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abfd7548027d5dbf95f55e37098b02b26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::mol_propagate_p </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Propagate nuclear momenta for all trajectories</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Integration time step (integration duration)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1085067dc164672b64624a576eb87673"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::mol_propagate_q </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Propagate nuclear coordinates for given trajectory</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Index of the trajectory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Integration time step (integration duration)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82d15c7ed6d862cb0e09e0e307cbd98a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::mol_propagate_q </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Propagate nuclear coordinates for all trajectories</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Integration time step (integration duration)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0bce68d307491607d2263fcc94a7929a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::print_map </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Xmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Xmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Ymin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Ymax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>snap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>for 2D projections on XY plane. Inactive now.</p>

</div>
</div>
<a class="anchor" id="abd76a66b4e9ece79c598be57f0a81b2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::se_pop </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>pops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute Schrodinger equation (coherent) populations</p>
<p>The computed population take into consideration the spatial localization of trajectories - only those trajectories that are in the given window between xmin and xmax. The trajectory is considered to be in that window if ALL nuclear DOF are larger than xmin but are smaller than xmax.</p>
<p>pops[i] - will contain the fraction of the wavefunction (as given by the average weight) of i-th electronic basis state that is enclosed by a box [xmin, xmax] in all dimensions (x,y,z) and for all nuclear degrees of freedom</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pops</td><td>The computed populations are saved into this vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xmin</td><td>The minimal boundary of spatial window </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xmax</td><td>The maximal boundary of spatial window</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90e7c411ac53e9308b0c26a45da1a685"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::se_pop </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>pops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute Schrodinger equation (coherent) populations</p>
<p>Wavefunction population of all states, without regard to nuclear wavefunction localization This is done by taking very large box If you are out of this box - this is kinda strange (you need to reduce time of simulation, maybe)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pops</td><td>The computed populations are saved into this vector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a429a9ea2294f6f2e9bbab13b39a20ba3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::python::list liblibra::libdyn::libensemble::Ensemble::se_pop </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute Schrodinger equation (coherent) populations - Python-friendly version</p>
<p>The computed population take into consideration the spatial localization of trajectories - only those trajectories that are in the given window between xmin and xmax. The trajectory is considered to be in that window if ALL nuclear DOF are larger than xmin but are smaller than xmax.</p>
<p>pops[i] - will contain the fraction of the wavefunction (as given by the average weight) of i-th electronic basis state that is enclosed by a box [xmin, xmax] in all dimensions (x,y,z) and for all nuclear degrees of freedom</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xmin</td><td>The minimal boundary of spatial window </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xmax</td><td>The maximal boundary of spatial window</td></tr>
  </table>
  </dd>
</dl>
<p>The computed vector of populations will be returned as the list of the floating-point values</p>

</div>
</div>
<a class="anchor" id="ac946398aaef7bbb91957a28844dbace3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::python::list liblibra::libdyn::libensemble::Ensemble::se_pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute Schrodinger equation (coherent) populations - Python-friendly version</p>
<p>Wavefunction population of all states, without regard to nuclear wavefunction localization This is done by taking very large box If you are out of this box - this is kinda strange (you need to reduce time of simulation, maybe)</p>
<p>The computed vector of populations will be returned as the list of the floating-point values</p>

</div>
</div>
<a class="anchor" id="aed1f63c67b86b5d11ed19b80f20578a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::sh_pop </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>pops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute surface hopping (incoherent) populations</p>
<p>The computed population take into consideration the spatial localization of trajectories - only those trajectories that are in the given window between xmin and xmax. The trajectory is considered to be in that window if ALL nuclear DOF are larger than xmin but are smaller than xmax.</p>
<p>pops[i] - will contain the fraction of the wavefunction (as given by the average weight) of i-th electronic basis state that is enclosed by a box [xmin, xmax] in all dimensions (x,y,z) and for all nuclear degrees of freedom</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pops</td><td>The computed populations are saved into this vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xmin</td><td>The minimal boundary of spatial window </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xmax</td><td>The maximal boundary of spatial window</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61dc0755adec6f7f81e6c1d03e1d4593"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::sh_pop </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>pops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute surface hopping (incoherent) populations</p>
<p>Wavefunction population of all states, without regard to nuclear wavefunction localization This is done by taking very large box If you are out of this box - this is kinda strange (you need to reduce time of simulation, maybe)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pops</td><td>The computed populations are saved into this vector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a117952cbe0dd1ad8127b6c6453a5ddf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::python::list liblibra::libdyn::libensemble::Ensemble::sh_pop </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute surface hopping (incoherent) populations - Python-friendly version</p>
<p>The computed population take into consideration the spatial localization of trajectories - only those trajectories that are in the given window between xmin and xmax. The trajectory is considered to be in that window if ALL nuclear DOF are larger than xmin but are smaller than xmax.</p>
<p>pops[i] - will contain the fraction of the wavefunction (as given by the average weight) of i-th electronic basis state that is enclosed by a box [xmin, xmax] in all dimensions (x,y,z) and for all nuclear degrees of freedom</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xmin</td><td>The minimal boundary of spatial window </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xmax</td><td>The maximal boundary of spatial window</td></tr>
  </table>
  </dd>
</dl>
<p>The computed vector of populations will be returned as the list of the floating-point values</p>

</div>
</div>
<a class="anchor" id="af858c6dc564f34ef42e3ad06d25efe01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::python::list liblibra::libdyn::libensemble::Ensemble::sh_pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute surface hopping (incoherent) populations - Python-friendly version</p>
<p>Wavefunction population of all states, without regard to nuclear wavefunction localization This is done by taking very large box If you are out of this box - this is kinda strange (you need to reduce time of simulation, maybe)</p>
<p>The computed vector of populations will be returned as the list of the floating-point values</p>

</div>
</div>
<a class="anchor" id="a93448fbb256f701e87186ff8ab28259f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::sh_pop1 </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>pops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute surface hopping (incoherent) populations</p>
<p>This is specially for Marcus spin-boson problem</p>
<p>The computed population take into consideration the spatial localization of trajectories - only those trajectories that are in the given window between xmin and xmax. The trajectory is considered to be in that window if ALL nuclear DOF are larger than xmin but are smaller than xmax.</p>
<p>pops[i] - will contain the fraction of the wavefunction (as given by the average weight) of i-th electronic basis state that is enclosed by a box [xmin, xmax] in all dimensions (x,y,z) and for all nuclear degrees of freedom</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pops</td><td>The computed populations are saved into this vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xmin</td><td>The minimal boundary of spatial window </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xmax</td><td>The maximal boundary of spatial window</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac66b6c61ad9f9381964b6410b846d4d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libensemble::Ensemble::sh_pop1 </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>pops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute surface hopping (incoherent) populations</p>
<p>This is specially for Marcus spin-boson problem</p>
<p>Wavefunction population of all states, without regard to nuclear wavefunction localization This is done by taking very large box If you are out of this box - this is kinda strange (you need to reduce time of simulation, maybe)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pops</td><td>The computed populations are saved into this vector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5bc83bae567c3d94846fa3fcd3561b49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::python::list liblibra::libdyn::libensemble::Ensemble::sh_pop1 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute surface hopping (incoherent) populations - Python-friendly version</p>
<p>This is specially for Marcus spin-boson problem</p>
<p>The computed population take into consideration the spatial localization of trajectories - only those trajectories that are in the given window between xmin and xmax. The trajectory is considered to be in that window if ALL nuclear DOF are larger than xmin but are smaller than xmax.</p>
<p>pops[i] - will contain the fraction of the wavefunction (as given by the average weight) of i-th electronic basis state that is enclosed by a box [xmin, xmax] in all dimensions (x,y,z) and for all nuclear degrees of freedom</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xmin</td><td>The minimal boundary of spatial window </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xmax</td><td>The maximal boundary of spatial window</td></tr>
  </table>
  </dd>
</dl>
<p>The computed vector of populations will be returned as the list of the floating-point values</p>

</div>
</div>
<a class="anchor" id="acc2cf79e01561ee906870b035a91c98d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::python::list liblibra::libdyn::libensemble::Ensemble::sh_pop1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute surface hopping (incoherent) populations - Python-friendly version</p>
<p>This is specially for Marcus spin-boson problem</p>
<p>Wavefunction population of all states, without regard to nuclear wavefunction localization This is done by taking very large box If you are out of this box - this is kinda strange (you need to reduce time of simulation, maybe)</p>
<p>The computed vector of populations will be returned as the list of the floating-point values</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a6937dabc774114a52fbb423dedb3eb63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int liblibra::libdyn::libensemble::Ensemble::ntraj</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html">Ensemble</a> class that is designed to propagate many trajectories (entangled or independent) at once. </p>
<p>Object of <a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html">Ensemble</a> type essentially represents a time-dependent electron-nuclear wavefunction el - represents electronic component mol - represent nuclear component This is a semiclassical representation of a wavefunction via a swarm (ensemble) of trajectories</p>
<p>PSI(t) = sum_k { delta((R,P)-mol[k]) * sum_i { el[k][i] * |i;k&gt; } }</p>
<p>mol[k] - k-th copy of the nuclear system (k-th trajectory) el[k][i] - coefficients of i-th electronic basis state associated with k-th copy of the system |i;k&gt; - is i-th electronic basis state parameterized by nuclear degrees of freedom mol[k] number of trajectories in ensemble </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/travis/build/Quantum-Dynamics-Hub/libra-code/src/dyn/ensemble/<a class="el" href="Ensemble_8h_source.html">Ensemble.h</a></li>
<li>/home/travis/build/Quantum-Dynamics-Hub/libra-code/src/dyn/ensemble/<a class="el" href="Ensemble_8cpp.html">Ensemble.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 25 2017 14:01:31 for Libra by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
