<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Libra: liblibra::libdyn::libelectronic Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Libra
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceliblibra.html">liblibra</a></li><li class="navelem"><a class="el" href="namespaceliblibra_1_1libdyn.html">libdyn</a></li><li class="navelem"><a class="el" href="namespaceliblibra_1_1libdyn_1_1libelectronic.html">libelectronic</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">liblibra::libdyn::libelectronic Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>libelectronic namespace  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afd3b7a6d2dd17083902c31196baf2759"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd3b7a6d2dd17083902c31196baf2759"></a>
typedef std::vector&lt; <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn_1_1libelectronic.html#afd3b7a6d2dd17083902c31196baf2759">ElectronicList</a></td></tr>
<tr class="memdesc:afd3b7a6d2dd17083902c31196baf2759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type containing the vector of <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> objects. <br/></td></tr>
<tr class="separator:afd3b7a6d2dd17083902c31196baf2759"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7fb81dbd6affb578b0f3c62de29e83c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn_1_1libelectronic.html#a7fb81dbd6affb578b0f3c62de29e83c9">propagate_electronic</a> (double dt, <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> *el, <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> *ham)</td></tr>
<tr class="separator:a7fb81dbd6affb578b0f3c62de29e83c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac900e1a2df6ad0c7e45cd7c6256ad417"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn_1_1libelectronic.html#ac900e1a2df6ad0c7e45cd7c6256ad417">propagate_electronic</a> (double dt, <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> &amp;el, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> &amp;Hvib)</td></tr>
<tr class="separator:ac900e1a2df6ad0c7e45cd7c6256ad417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf6c030c3eaa0d1f820d19b0293ff49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn_1_1libelectronic.html#a0bf6c030c3eaa0d1f820d19b0293ff49">propagate_electronic</a> (double dt, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> &amp;Coeff, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> &amp;Hvib)</td></tr>
<tr class="separator:a0bf6c030c3eaa0d1f820d19b0293ff49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89386d32acc6de72b755af93d7f06d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn_1_1libelectronic.html#ad89386d32acc6de72b755af93d7f06d5">propagate_electronic</a> (double dt, <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> &amp;el, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> &amp;Hvib, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> &amp;S)</td></tr>
<tr class="separator:ad89386d32acc6de72b755af93d7f06d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d4c86539b2e63944c02886656cdb40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn_1_1libelectronic.html#a53d4c86539b2e63944c02886656cdb40">propagate_electronic</a> (double dt, <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> &amp;el, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> &amp;Hvib, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> &amp;S)</td></tr>
<tr class="separator:a53d4c86539b2e63944c02886656cdb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90156f559a6c6a275eb3391da5b38bb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn_1_1libelectronic.html#a90156f559a6c6a275eb3391da5b38bb2">propagate_electronic</a> (double dt, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> &amp;Coeff, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> &amp;Hvib, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> &amp;S)</td></tr>
<tr class="separator:a90156f559a6c6a275eb3391da5b38bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074d4792084ac4ef607970a732996dd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn_1_1libelectronic.html#a074d4792084ac4ef607970a732996dd6">grid_propagator</a> (double dt, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> &amp;Hvib, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> &amp;S, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> &amp;U)</td></tr>
<tr class="separator:a074d4792084ac4ef607970a732996dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e0fe6a98ae5bddd1ade6e56f212757"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn_1_1libelectronic.html#a34e0fe6a98ae5bddd1ade6e56f212757">export_Electronic_objects</a> ()</td></tr>
<tr class="separator:a34e0fe6a98ae5bddd1ade6e56f212757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698a5b5d8e04c9e32765be05b0354d33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a698a5b5d8e04c9e32765be05b0354d33"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_PYTHON_MODULE</b> (libelectronic)</td></tr>
<tr class="separator:a698a5b5d8e04c9e32765be05b0354d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>libelectronic namespace </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a34e0fe6a98ae5bddd1ade6e56f212757"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libelectronic::export_Electronic_objects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exporter of libelectronic classes and functions</p>

</div>
</div>
<a class="anchor" id="a074d4792084ac4ef607970a732996dd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libelectronic::grid_propagator </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX &amp;&#160;</td>
          <td class="paramname"><em>Hvib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX &amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A super-fast version specifically taylored to grid integration (since grid is known, the matrices S, Hvib and all the dependent matrices are fixed, so can be computed only once and then passed here)</p>
<p>Solves the generalized time-dependent Schrodinger equation:</p>
<p>i*hbar*S*dc/dt = Hvib*c</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>The integration time step (also the duration of propagation) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Hvib</td><td>The reference to the vibronic Hamiltonian matrix (not the Hamiltonian object!) - the complex-valued matrix, CMATRIX it is also assumed to be Hermitian - pay attention to how it is constructed! </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>The reference to the overlap matrix (assumed to be a complex-valued time-dependent matrix, CMATRIX)</td></tr>
  </table>
  </dd>
</dl>
<p>This is the Python-friendly function This function returns a propagator</p>
<p>A super-fast version specifically taylored to grid integration (since grid is known, the matrices S, Hvib and all the dependent matrices are fixed, so can be computed only once and then passed here)</p>
<p>Solves the generalized time-dependent Schrodinger equation:</p>
<p>i*hbar*S*dc/dt = Hvib*c</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>The integration time step (also the duration of propagation) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Hvib</td><td>The reference to the vibronic Hamiltonian matrix (not the Hamiltonian object!) - the complex-valued matrix, CMATRIX it is also assumed to be Hermitian - pay attention to how it is constructed! </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>The reference to the overlap matrix (assumed to be a complex-valued time-dependent matrix, CMATRIX)</td></tr>
  </table>
  </dd>
</dl>
<p>This is the Python-friendly function This function returns a propagator</p>

</div>
</div>
<a class="anchor" id="a7fb81dbd6affb578b0f3c62de29e83c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libelectronic::propagate_electronic </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Electronic *&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hamiltonian *&#160;</td>
          <td class="paramname"><em>ham</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Propagate electronic DOF using sequential rotations in the MMTS variables</p>
<p>Methodologically: This version is based on the Hamiltonian formulation of TD-SE This propagator is good for general Hamiltonian - diabatic of adiabatic iL = iL_qp + iL_qq + iL_pp iL_qp = sum_i,j {}</p>
<p>API: A free function that takes <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> object as the input and modifies it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>The integration time step (also the duration of propagation) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">el</td><td>The pointer to the <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> object containing the electronic DOF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ham</td><td>The pointer to Hamiltonian object, that affects the dynamics</td></tr>
  </table>
  </dd>
</dl>
<p>Propagate electronic DOF using sequential rotations in the MMTS variables</p>
<p>Methodologically: This version is based on the Hamiltonian formulation of TD-SE This propagator is good for general Hamiltonian - diabatic of adiabatic iL = iL_qp + iL_qq + iL_pp iL_qp = sum_i,j {}</p>
<p>API: A free function that takes <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> object as the input and modifies it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>The integration time step (also the duration of propagation) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">el</td><td>The pointer to the <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> object containing the electronic DOF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ham</td><td>The pointer to Hamiltonian object, that affects the dynamics</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac900e1a2df6ad0c7e45cd7c6256ad417"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libelectronic::propagate_electronic </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Electronic &amp;&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX &amp;&#160;</td>
          <td class="paramname"><em>Hvib</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Propagate electronic DOF using sequential rotations in the MMTS variables</p>
<p>Methodologically: This version is based on the Hamiltonian formulation of TD-SE This propagator is good for general Hamiltonian - diabatic of adiabatic iL = iL_qp + iL_qq + iL_pp iL_qp = sum_i,j {}</p>
<p>API: A free function that takes <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> object as the input and modifies it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>The integration time step (also the duration of propagation) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">el</td><td>The reference to the <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> object containing the electronic DOF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ham</td><td>The reference to the vibronic Hamiltonian matrix (not the Hamiltonian object!)</td></tr>
  </table>
  </dd>
</dl>
<p>This is the Python-friendly function</p>
<p>Propagate electronic DOF using sequential rotations in the MMTS variables</p>
<p>Methodologically: This version is based on the Hamiltonian formulation of TD-SE This propagator is good for general Hamiltonian - diabatic of adiabatic iL = iL_qp + iL_qq + iL_pp iL_qp = sum_i,j {}</p>
<p>API: A free function that takes <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> object as the input and modifies it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>The integration time step (also the duration of propagation) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">el</td><td>The reference to the <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> object containing the electronic DOF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ham</td><td>The reference to the vibronic Hamiltonian matrix (not the Hamiltonian object!)</td></tr>
  </table>
  </dd>
</dl>
<p>This is the Python-friendly function</p>

</div>
</div>
<a class="anchor" id="a0bf6c030c3eaa0d1f820d19b0293ff49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libelectronic::propagate_electronic </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX &amp;&#160;</td>
          <td class="paramname"><em>Coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX &amp;&#160;</td>
          <td class="paramname"><em>Hvib</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solves the time-dependent Schrodinger equation:</p>
<p>i*hbar*dc/dt = Hvib*c</p>
<p>API: A free function that takes electronic DOF in the form of matrix-colomun and modifies it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>The integration time step (also the duration of propagation) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Coeff</td><td>The reference to the CMATRIX object containing the electronic DOF (coefficient) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ham</td><td>The reference to the vibronic Hamiltonian matrix (not the Hamiltonian object!) - the complex-valued matrix, CMATRIX it is also assumed to Hermitian - pay attention to how it is constructed! </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>The reference to the overlap matrix (assumed to be a complex-valued time-dependent matrix, CMATRIX)</td></tr>
  </table>
  </dd>
</dl>
<p>This integrator IS unitary This is the Python-friendly function</p>
<p>Solves the time-dependent Schrodinger equation:</p>
<p>i*hbar*dc/dt = Hvib*c</p>
<p>API: A free function that takes electronic DOF in the form of matrix-colomun and modifies it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>The integration time step (also the duration of propagation) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Coeff</td><td>The reference to the CMATRIX object containing the electronic DOF (coefficient) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ham</td><td>The reference to the vibronic Hamiltonian matrix (not the Hamiltonian object!) - the complex-valued matrix, CMATRIX it is also assumed to Hermitian - pay attention to how it is constructed! </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>The reference to the overlap matrix (assumed to be a complex-valued time-dependent matrix, CMATRIX)</td></tr>
  </table>
  </dd>
</dl>
<p>This integrator IS unitary This is the Python-friendly function</p>

</div>
</div>
<a class="anchor" id="ad89386d32acc6de72b755af93d7f06d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libelectronic::propagate_electronic </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Electronic &amp;&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX &amp;&#160;</td>
          <td class="paramname"><em>Hvib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Propagate electronic DOF in the MMTS variables</p>
<p>Methodologically: solve i*hbar*S*dc/dt = Hvib*c directly, using Lowdin-type transformation and matrix exponentiation. This solver is good only for time-independent S matrix</p>
<p>API: A free function that takes <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> object as the input and modifies it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>The integration time step (also the duration of propagation) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">el</td><td>The reference to the <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> object containing the electronic DOF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ham</td><td>The reference to the vibronic Hamiltonian matrix (not the Hamiltonian object!) - the complex-valued matrix, CMATRIX </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>The reference to the overlap matrix (assumed to be a real-valued matrix, MATRIX)</td></tr>
  </table>
  </dd>
</dl>
<p>This integrator is fully unitary (the norm is conserved exactly) This is the Python-friendly function</p>
<p>Propagate electronic DOF in the MMTS variables</p>
<p>Methodologically: solve i*hbar*S*dc/dt = Hvib*c directly, using Lowdin-type transformation and matrix exponentiation. This solver is good only for time-independent S matrix</p>
<p>API: A free function that takes <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> object as the input and modifies it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>The integration time step (also the duration of propagation) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">el</td><td>The reference to the <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> object containing the electronic DOF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ham</td><td>The reference to the vibronic Hamiltonian matrix (not the Hamiltonian object!) - the complex-valued matrix, CMATRIX </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>The reference to the overlap matrix (assumed to be a real-valued matrix, MATRIX)</td></tr>
  </table>
  </dd>
</dl>
<p>This integrator is fully unitary (the norm is conserved exactly) This is the Python-friendly function</p>

</div>
</div>
<a class="anchor" id="a53d4c86539b2e63944c02886656cdb40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libelectronic::propagate_electronic </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Electronic &amp;&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX &amp;&#160;</td>
          <td class="paramname"><em>Hvib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Propagate electronic DOF in the MMTS variables</p>
<p>Methodologically: solve i*hbar*S*dc/dt = Hvib*c directly, using Lowdin-type transformation and matrix exponentiation. This solver is good only for time-independent S matrix</p>
<p>API: A free function that takes <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> object as the input and modifies it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>The integration time step (also the duration of propagation) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">el</td><td>The reference to the <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> object containing the electronic DOF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ham</td><td>The reference to the vibronic Hamiltonian matrix (not the Hamiltonian object!) - the complex-valued matrix, CMATRIX </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>The reference to the overlap matrix (assumed to be a complex-valued matrix, CMATRIX)</td></tr>
  </table>
  </dd>
</dl>
<p>This integrator is fully unitary (the norm is conserved exactly) This is the Python-friendly function</p>
<p>Propagate electronic DOF in the MMTS variables</p>
<p>Methodologically: solve i*hbar*S*dc/dt = Hvib*c directly, using Lowdin-type transformation and matrix exponentiation. This solver is good only for time-independent S matrix</p>
<p>API: A free function that takes <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> object as the input and modifies it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>The integration time step (also the duration of propagation) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">el</td><td>The reference to the <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> object containing the electronic DOF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ham</td><td>The reference to the vibronic Hamiltonian matrix (not the Hamiltonian object!) - the complex-valued matrix, CMATRIX </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>The reference to the overlap matrix (assumed to be a complex-valued matrix, CMATRIX)</td></tr>
  </table>
  </dd>
</dl>
<p>This integrator is fully unitary (the norm is conserved exactly) This is the Python-friendly function</p>

</div>
</div>
<a class="anchor" id="a90156f559a6c6a275eb3391da5b38bb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::libelectronic::propagate_electronic </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX &amp;&#160;</td>
          <td class="paramname"><em>Coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX &amp;&#160;</td>
          <td class="paramname"><em>Hvib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solves the generalized time-dependent Schrodinger equation:</p>
<p>i*hbar*S*dc/dt = Hvib*c</p>
<p>Although the vibronic Hamiltonian, Hvib_tilda, computed in the non-orthonormal basis is not Hermitian, the theory eventually leads to a Hermitian version of the vibronic Hamiltonian, so we take the Hermitian one as the input. See my paper on the details.</p>
<p>API: A free function that takes electronic DOF in the form of matrix-colomun and modifies it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>The integration time step (also the duration of propagation) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Coeff</td><td>The reference to the CMATRIX object containing the electronic DOF (coefficient) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ham</td><td>The reference to the vibronic Hamiltonian matrix (not the Hamiltonian object!) - the complex-valued matrix, CMATRIX it is also assumed to Hermitian - pay attention to how it is constructed! </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>The reference to the overlap matrix (assumed to be a complex-valued time-dependent matrix, CMATRIX)</td></tr>
  </table>
  </dd>
</dl>
<p>This integrator IS unitary This is the Python-friendly function</p>
<p>Solves the generalized time-dependent Schrodinger equation:</p>
<p>i*hbar*S*dc/dt = Hvib*c</p>
<p>Although the vibronic Hamiltonian, Hvib_tilda, computed in the non-orthonormal basis is not Hermitian, the theory eventually leads to a Hermitian version of the vibronic Hamiltonian, so we take the Hermitian one as the input. See my paper on the details.</p>
<p>API: A free function that takes electronic DOF in the form of matrix-colomun and modifies it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>The integration time step (also the duration of propagation) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Coeff</td><td>The reference to the CMATRIX object containing the electronic DOF (coefficient) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ham</td><td>The reference to the vibronic Hamiltonian matrix (not the Hamiltonian object!) - the complex-valued matrix, CMATRIX it is also assumed to Hermitian - pay attention to how it is constructed! </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>The reference to the overlap matrix (assumed to be a complex-valued time-dependent matrix, CMATRIX)</td></tr>
  </table>
  </dd>
</dl>
<p>This integrator IS unitary This is the Python-friendly function</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 25 2017 14:01:31 for Libra by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
