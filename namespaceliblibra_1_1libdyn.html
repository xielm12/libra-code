<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Libra: liblibra::libdyn Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Libra
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceliblibra.html">liblibra</a></li><li class="navelem"><a class="el" href="namespaceliblibra_1_1libdyn.html">libdyn</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">liblibra::libdyn Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>libdyn namespace  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceliblibra_1_1libdyn_1_1libbarostat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn_1_1libbarostat.html">libbarostat</a></td></tr>
<tr class="memdesc:namespaceliblibra_1_1libdyn_1_1libbarostat"><td class="mdescLeft">&#160;</td><td class="mdescRight">libbarostat namespace <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceliblibra_1_1libdyn_1_1libelectronic"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn_1_1libelectronic.html">libelectronic</a></td></tr>
<tr class="memdesc:namespaceliblibra_1_1libdyn_1_1libelectronic"><td class="mdescLeft">&#160;</td><td class="mdescRight">libelectronic namespace <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceliblibra_1_1libdyn_1_1libensemble"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn_1_1libensemble.html">libensemble</a></td></tr>
<tr class="memdesc:namespaceliblibra_1_1libdyn_1_1libensemble"><td class="mdescLeft">&#160;</td><td class="mdescRight">libensemble namespace <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceliblibra_1_1libdyn_1_1libgwp"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn_1_1libgwp.html">libgwp</a></td></tr>
<tr class="memdesc:namespaceliblibra_1_1libdyn_1_1libgwp"><td class="mdescLeft">&#160;</td><td class="mdescRight">libgwp namespace <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceliblibra_1_1libdyn_1_1libnuclear"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn_1_1libnuclear.html">libnuclear</a></td></tr>
<tr class="memdesc:namespaceliblibra_1_1libdyn_1_1libnuclear"><td class="mdescLeft">&#160;</td><td class="mdescRight">libnuclear namespace <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceliblibra_1_1libdyn_1_1libthermostat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn_1_1libthermostat.html">libthermostat</a></td></tr>
<tr class="memdesc:namespaceliblibra_1_1libdyn_1_1libthermostat"><td class="mdescLeft">&#160;</td><td class="mdescRight">libthermostat namespace <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceliblibra_1_1libdyn_1_1libwfcgrid"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn_1_1libwfcgrid.html">libwfcgrid</a></td></tr>
<tr class="memdesc:namespaceliblibra_1_1libdyn_1_1libwfcgrid"><td class="mdescLeft">&#160;</td><td class="mdescRight">libwfcgrid namespace <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae5f77aff460464653b3e1a12dba4548c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#ae5f77aff460464653b3e1a12dba4548c">propagate_ensemble</a> (double dt, <a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html">Ensemble</a> *ens, int opt)</td></tr>
<tr class="separator:ae5f77aff460464653b3e1a12dba4548c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7efcecf345f89cb24be4c3d1af8fb18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#ad7efcecf345f89cb24be4c3d1af8fb18">propagate_ensemble</a> (double dt, <a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html">Ensemble</a> &amp;ens, int opt)</td></tr>
<tr class="separator:ad7efcecf345f89cb24be4c3d1af8fb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f262f1444a5ee18b6713c930eec7c71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a9f262f1444a5ee18b6713c930eec7c71">propagate_nuclear</a> (double dt, <a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> *mol, <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> *el, <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> *ham, int opt)</td></tr>
<tr class="separator:a9f262f1444a5ee18b6713c930eec7c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cc179f143d4167bb8b8df0cb523b8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#af8cc179f143d4167bb8b8df0cb523b8c">propagate_nuclear</a> (double dt, <a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> *mol, <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> *el, <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> *ham, <a class="el" href="classliblibra_1_1libdyn_1_1libthermostat_1_1Thermostat.html">Thermostat</a> *therm, int opt)</td></tr>
<tr class="separator:af8cc179f143d4167bb8b8df0cb523b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f1be44f239fbdb9613cb93ba163a1b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a57f1be44f239fbdb9613cb93ba163a1b">compute_kinetic_energy</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> *mol)</td></tr>
<tr class="separator:a57f1be44f239fbdb9613cb93ba163a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3274a92a79391a7d0380cdea036253f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#ab3274a92a79391a7d0380cdea036253f">compute_kinetic_energy</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> &amp;mol)</td></tr>
<tr class="separator:ab3274a92a79391a7d0380cdea036253f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed0087c124682f82858dd0baad6f511"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#aaed0087c124682f82858dd0baad6f511">compute_kinetic_energy</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html">Ensemble</a> &amp;ens)</td></tr>
<tr class="separator:aaed0087c124682f82858dd0baad6f511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023501af48d4c56a7124a5f4da477db8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a023501af48d4c56a7124a5f4da477db8">compute_potential_energy</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> *mol, <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> *el, <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> *ham, int opt)</td></tr>
<tr class="separator:a023501af48d4c56a7124a5f4da477db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae8cc29e5622a80dc3e4c26944d55ca"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#adae8cc29e5622a80dc3e4c26944d55ca">compute_potential_energy</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> &amp;mol, <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> &amp;el, <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> &amp;ham, int opt)</td></tr>
<tr class="separator:adae8cc29e5622a80dc3e4c26944d55ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ad9f5bd839e78fda590d11575ae8d0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a76ad9f5bd839e78fda590d11575ae8d0">compute_potential_energy</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html">Ensemble</a> &amp;ens, int opt)</td></tr>
<tr class="separator:a76ad9f5bd839e78fda590d11575ae8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf870d997b677131186f31ec4323617"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a3cf870d997b677131186f31ec4323617">compute_forces</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> *mol, <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> *el, <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> *ham, int opt)</td></tr>
<tr class="separator:a3cf870d997b677131186f31ec4323617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e96e5faa8601a5e13136766c2f82b7b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a9e96e5faa8601a5e13136766c2f82b7b">compute_forces</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> &amp;mol, <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> &amp;el, <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> &amp;ham, int opt)</td></tr>
<tr class="separator:a9e96e5faa8601a5e13136766c2f82b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2bb1efd1f84a96dbf0f7b7b94772e77"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#ac2bb1efd1f84a96dbf0f7b7b94772e77">compute_forces</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html">Ensemble</a> &amp;ens, int opt)</td></tr>
<tr class="separator:ac2bb1efd1f84a96dbf0f7b7b94772e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0a4f9106020c2f99a5f40227693308"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a0b0a4f9106020c2f99a5f40227693308">compute_energies</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html">Ensemble</a> *ens, double &amp;Epot, double &amp;Ekin, double &amp;Etot, int opt)</td></tr>
<tr class="separator:a0b0a4f9106020c2f99a5f40227693308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac46175ec66d05aea89ed38be47e3ff1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#aac46175ec66d05aea89ed38be47e3ff1">export_Dyn_objects</a> ()</td></tr>
<tr class="separator:aac46175ec66d05aea89ed38be47e3ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8770eb59ed60d3f9c46faf159f8bcd68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8770eb59ed60d3f9c46faf159f8bcd68"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_PYTHON_MODULE</b> (libdyn)</td></tr>
<tr class="separator:a8770eb59ed60d3f9c46faf159f8bcd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa1062947434817b4ac00b3845348e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a2fa1062947434817b4ac00b3845348e4">compute_hopping_probabilities_fssh</a> (<a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> &amp;Coeff, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> &amp;Hvib, double dt)</td></tr>
<tr class="separator:a2fa1062947434817b4ac00b3845348e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e73a64ac17d4e92a774e4c51d4b9ea6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a1e73a64ac17d4e92a774e4c51d4b9ea6">compute_hopping_probabilities_fssh</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> *mol, <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> *el, <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> *ham, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *g, double dt, int use_boltz_factor, double T)</td></tr>
<tr class="separator:a1e73a64ac17d4e92a774e4c51d4b9ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e27a4e93a7a23ba9277d9faf7a4a119"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a1e27a4e93a7a23ba9277d9faf7a4a119">compute_hopping_probabilities_fssh</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> &amp;mol, <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> &amp;el, <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> &amp;ham, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> &amp;g, double dt, int use_boltz_factor, double T)</td></tr>
<tr class="separator:a1e27a4e93a7a23ba9277d9faf7a4a119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949e0aa843a01adb9d958d8cd12f7cc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a949e0aa843a01adb9d958d8cd12f7cc1">compute_hopping_probabilities_fssh</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html">Ensemble</a> &amp;ens, int i, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> &amp;g, double dt, int use_boltz_factor, double T)</td></tr>
<tr class="separator:a949e0aa843a01adb9d958d8cd12f7cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d5e94d410b43db896244ddfccd0c7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a79d5e94d410b43db896244ddfccd0c7d">compute_hopping_probabilities_gfsh</a> (<a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> &amp;Coeff, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> &amp;Hvib, double dt)</td></tr>
<tr class="separator:a79d5e94d410b43db896244ddfccd0c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6004f3b0aa54c03e0f0384d51d38a464"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a6004f3b0aa54c03e0f0384d51d38a464">compute_hopping_probabilities_gfsh</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> *mol, <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> *el, <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> *ham, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *g, double dt, int use_boltz_factor, double T)</td></tr>
<tr class="separator:a6004f3b0aa54c03e0f0384d51d38a464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431a97197960b04631bc5e0878b3a118"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a431a97197960b04631bc5e0878b3a118">compute_hopping_probabilities_gfsh</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> &amp;mol, <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> &amp;el, <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> &amp;ham, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> &amp;g, double dt, int use_boltz_factor, double T)</td></tr>
<tr class="separator:a431a97197960b04631bc5e0878b3a118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432545e27a8b47653a0ace1c7cf154d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a432545e27a8b47653a0ace1c7cf154d0">compute_hopping_probabilities_gfsh</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html">Ensemble</a> &amp;ens, int i, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> &amp;g, double dt, int use_boltz_factor, double T)</td></tr>
<tr class="separator:a432545e27a8b47653a0ace1c7cf154d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa232f18b1a993a1a99820ef687eaa53a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#aa232f18b1a993a1a99820ef687eaa53a">compute_hopping_probabilities_mssh</a> (<a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> &amp;Coeff)</td></tr>
<tr class="separator:aa232f18b1a993a1a99820ef687eaa53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7771b115bf8783c8bef0f85748f5b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a7d7771b115bf8783c8bef0f85748f5b3">compute_hopping_probabilities_mssh</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> *mol, <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> *el, <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> *ham, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *g, double dt, int use_boltz_factor, double T)</td></tr>
<tr class="separator:a7d7771b115bf8783c8bef0f85748f5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213d0cefa7bb0481849ad9ed16b13c47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a213d0cefa7bb0481849ad9ed16b13c47">compute_hopping_probabilities_mssh</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> &amp;mol, <a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> &amp;el, <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> &amp;ham, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> &amp;g, double dt, int use_boltz_factor, double T)</td></tr>
<tr class="separator:a213d0cefa7bb0481849ad9ed16b13c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4c024ac2fb01e12b444a5eaaf32ac3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a6c4c024ac2fb01e12b444a5eaaf32ac3">compute_hopping_probabilities_mssh</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html">Ensemble</a> &amp;ens, int i, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> &amp;g, double dt, int use_boltz_factor, double T)</td></tr>
<tr class="separator:a6c4c024ac2fb01e12b444a5eaaf32ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad915d6355d45091809d1e3b8a72ce3da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#ad915d6355d45091809d1e3b8a72ce3da">hop</a> (int initstate, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> &amp;g, double ksi)</td></tr>
<tr class="separator:ad915d6355d45091809d1e3b8a72ce3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a84d6f7347afd1f299633c9ef80030"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a69a84d6f7347afd1f299633c9ef80030">hop</a> (int &amp;initstate, <a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> *mol, <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> *ham, double ksi, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *g, int do_rescaling, int rep, int do_reverse)</td></tr>
<tr class="separator:a69a84d6f7347afd1f299633c9ef80030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d902216782095d624d55231e022ea55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a6d902216782095d624d55231e022ea55">hop</a> (int initstate, <a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> &amp;mol, <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> &amp;ham, double ksi, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> &amp;g, int do_rescaling, int rep, int do_reverse)</td></tr>
<tr class="separator:a6d902216782095d624d55231e022ea55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80700eaa7d1da741f206c73fd4e95193"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a80700eaa7d1da741f206c73fd4e95193">hop</a> (int initstate, <a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html">Ensemble</a> &amp;ens, int i, double ksi, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> &amp;g, int do_rescaling, int rep, int do_reverse)</td></tr>
<tr class="separator:a80700eaa7d1da741f206c73fd4e95193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e448956797c11e694036a4fce34b31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a10e448956797c11e694036a4fce34b31">rescale_velocities_adiabatic</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> *mol, <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> *ham, int &amp;new_st, int &amp;old_st, int do_reverse)</td></tr>
<tr class="separator:a10e448956797c11e694036a4fce34b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f1ba34575eaaee93f71bab4995c809"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#aa9f1ba34575eaaee93f71bab4995c809">rescale_velocities_adiabatic</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> &amp;mol, <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> &amp;ham, int old_st, int do_reverse)</td></tr>
<tr class="separator:aa9f1ba34575eaaee93f71bab4995c809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4853be2a1983134e633fcae0c21dd896"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a4853be2a1983134e633fcae0c21dd896">rescale_velocities_diabatic</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> *mol, <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> *ham, int &amp;new_st, int &amp;old_st)</td></tr>
<tr class="separator:a4853be2a1983134e633fcae0c21dd896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096dd57779b2a36c054adab74664a063"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a096dd57779b2a36c054adab74664a063">rescale_velocities_diabatic</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> &amp;mol, <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> &amp;ham, int old_st)</td></tr>
<tr class="separator:a096dd57779b2a36c054adab74664a063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8135a783124f7db594c46fd4d8e0e7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#ad8135a783124f7db594c46fd4d8e0e7e">ida</a> (<a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> &amp;Coeff, int old_st, int new_st, double E_old, double E_new, double T, double ksi)</td></tr>
<tr class="separator:ad8135a783124f7db594c46fd4d8e0e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c94741d60cb788e815adca9067eaf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a85c94741d60cb788e815adca9067eaf8">coherence_intervals</a> (const <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> &amp;Coeff, const <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> &amp;rates)</td></tr>
<tr class="separator:a85c94741d60cb788e815adca9067eaf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa4f65b0b719f456c57a7c29dd48101"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#adaa4f65b0b719f456c57a7c29dd48101">dish</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> &amp;el, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> &amp;t_m, const <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> &amp;tau_m, const <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> &amp;Hvib, int use_boltz_flag, double Ekin, double T, double ksi1, double ksi2)</td></tr>
<tr class="separator:adaa4f65b0b719f456c57a7c29dd48101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d1338a4ed5df78408e3bb7905806fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#a25d1338a4ed5df78408e3bb7905806fc">dish</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libelectronic_1_1Electronic.html">Electronic</a> &amp;el, <a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> &amp;mol, <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> &amp;ham, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> &amp;t_m, const <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> &amp;tau_m, int use_boltz_flag, double T, double ksi1, double ksi2)</td></tr>
<tr class="separator:a25d1338a4ed5df78408e3bb7905806fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5b75e151a9a330a8abb73cd9a931f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libdyn.html#aae5b75e151a9a330a8abb73cd9a931f5">compute_hopping_probabilities_esh</a> (<a class="el" href="classliblibra_1_1libdyn_1_1libensemble_1_1Ensemble.html">Ensemble</a> &amp;ens, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *g, double dt, int use_boltz_factor, double T)</td></tr>
<tr class="separator:aae5b75e151a9a330a8abb73cd9a931f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82a9ba147ce6e765f0b61628ea6003f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac82a9ba147ce6e765f0b61628ea6003f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>hop</b> (int ntraj, vector&lt; int &gt; &amp;initstate, vector&lt; <a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> * &gt; &amp;mol, vector&lt; <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> * &gt; &amp;ham, vector&lt; double &gt; ksi, vector&lt; <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> * &gt; &amp;g, int do_rescaling, int rep, int do_reverse)</td></tr>
<tr class="separator:ac82a9ba147ce6e765f0b61628ea6003f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7445b35db68c758afc6861bd9a7fad62"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7445b35db68c758afc6861bd9a7fad62"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>hop</b> (int ntraj, vector&lt; int &gt; initstate, vector&lt; <a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> &gt; &amp;mol, vector&lt; <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> &gt; &amp;ham, vector&lt; double &gt; ksi, vector&lt; <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> &gt; &amp;g, int do_rescaling, int rep, int do_reverse)</td></tr>
<tr class="separator:a7445b35db68c758afc6861bd9a7fad62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831cb8d06ef076976b5d4d4cbda6b616"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a831cb8d06ef076976b5d4d4cbda6b616"></a>
boost::python::list&#160;</td><td class="memItemRight" valign="bottom"><b>hop</b> (int ntraj, boost::python::list initstate, boost::python::list mol, boost::python::list ham, boost::python::list ksi, boost::python::list g, int do_rescaling, int rep, int do_reverse)</td></tr>
<tr class="separator:a831cb8d06ef076976b5d4d4cbda6b616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359dcc42ceb8706caaf7ebc9cbfcb285"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a359dcc42ceb8706caaf7ebc9cbfcb285"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>rescale_velocities_adiabatic</b> (int ntraj, vector&lt; <a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> * &gt; &amp;mol, vector&lt; <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> * &gt; &amp;ham, vector&lt; int &gt; &amp;new_st, vector&lt; int &gt; &amp;old_st, int do_reverse)</td></tr>
<tr class="separator:a359dcc42ceb8706caaf7ebc9cbfcb285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5f0267eca1b90c5dca8cb7ed812c1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c5f0267eca1b90c5dca8cb7ed812c1a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>rescale_velocities_adiabatic</b> (int ntraj, vector&lt; <a class="el" href="classliblibra_1_1libdyn_1_1libnuclear_1_1Nuclear.html">Nuclear</a> &gt; &amp;mol, vector&lt; <a class="el" href="classliblibra_1_1libhamiltonian_1_1libhamiltonian__generic_1_1Hamiltonian.html">Hamiltonian</a> &gt; &amp;ham, vector&lt; int &gt; &amp;new_st, vector&lt; int &gt; &amp;old_st, int do_reverse)</td></tr>
<tr class="separator:a9c5f0267eca1b90c5dca8cb7ed812c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>libdyn namespace </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a85c94741d60cb788e815adca9067eaf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> liblibra::libdyn::coherence_intervals </td>
          <td>(</td>
          <td class="paramtype">const CMATRIX &amp;&#160;</td>
          <td class="paramname"><em>Coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MATRIX &amp;&#160;</td>
          <td class="paramname"><em>rates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function computes the time-dependent (and population-dependent) coherence intervals (the time after which different states should experience a decoherence event) as described by Eq. 11 in: Jaeger, H. M.; Fischer, S.; Prezhdo, O. V. Decoherence-Induced Surface Hopping. J. Chem. Phys. 2012, 137, 22A545.</p>
<p>1/tau_i (t) = sum_(j!=i)^nstates { rho_ii(t) * rate_ij }</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Coeff</td><td>Amplitudes of the electronic states </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rates</td><td>A matrix containing the decoherence rates (inverse of the decoherence time for each given pair of states)</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: A matrix of the coherence intervals for each state</p>

</div>
</div>
<a class="anchor" id="a0b0a4f9106020c2f99a5f40227693308"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::compute_energies </td>
          <td>(</td>
          <td class="paramtype">Ensemble *&#160;</td>
          <td class="paramname"><em>ens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>Epot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>Ekin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>Etot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute ensemble-averaged potential, kinetic and total energy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ens</td><td>The pointer to Ensemble object for which we want to compute properties </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Epot</td><td>The computed averaged potential energy will be stored here </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Ekin</td><td>The computed averaged kinetic energy will be stored here </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Etot</td><td>The computed averaged total energy will be stored here </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opt</td><td>Option for selecting the way to describe the electron-nuclear interaction: = 0 - Ehrenfest (mean-field, MF), =1 - (fewest switched surface hopping, FSSH)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3cf870d997b677131186f31ec4323617"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double liblibra::libdyn::compute_forces </td>
          <td>(</td>
          <td class="paramtype">Nuclear *&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Electronic *&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hamiltonian *&#160;</td>
          <td class="paramname"><em>ham</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute potential energy and forces (an all classical DOF) of a quantum-classical system </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mol</td><td>Describes the nuclear DOF, is modified during calculations to update forces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">el</td><td>Describes electronic DOF </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ham</td><td>Is the Hamiltonian object that works as a functor (takes care of all calculations of given type) -its internal variables are changed during the compuations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opt</td><td>Option for selecting the way to describe the electron-nuclear interaction: = 0 - Ehrenfest (mean-field, MF), =1 - (fewest switched surface hopping, FSSH)</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the potential energy computed according to the selected option: either the poetial energy of an active electronic level (as given by el variable) - this is for opt = 1 - or the state averaged potential energy (the averaging also accounts for nonadiabatic couplings or off-diagonal Hamiltonian terms) - this is for opt = 0 The computed forces are stored in the mol object</p>

</div>
</div>
<a class="anchor" id="a9e96e5faa8601a5e13136766c2f82b7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double liblibra::libdyn::compute_forces </td>
          <td>(</td>
          <td class="paramtype">Nuclear &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Electronic &amp;&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hamiltonian &amp;&#160;</td>
          <td class="paramname"><em>ham</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute potential energy and forces (an all classical DOF) of a quantum-classical system - Python-friendly </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mol</td><td>Describes the nuclear DOF, is modified during calculations to update forces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">el</td><td>Describes electronic DOF </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ham</td><td>Is the Hamiltonian object that works as a functor (takes care of all calculations of given type) -its internal variables are changed during the compuations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opt</td><td>Option for selecting the way to describe the electron-nuclear interaction: = 0 - Ehrenfest (mean-field, MF), =1 - (fewest switched surface hopping, FSSH)</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the potential energy computed according to the selected option: either the poetial energy of an active electronic level (as given by el variable) - this is for opt = 1 - or the state averaged potential energy (the averaging also accounts for nonadiabatic couplings or off-diagonal Hamiltonian terms) - this is for opt = 0 The computed forces are stored in the mol object</p>

</div>
</div>
<a class="anchor" id="ac2bb1efd1f84a96dbf0f7b7b94772e77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double liblibra::libdyn::compute_forces </td>
          <td>(</td>
          <td class="paramtype">Ensemble &amp;&#160;</td>
          <td class="paramname"><em>ens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute potential energy and forces (an all classical DOF) of a quantum-classical system </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ens</td><td>The reference to the ensemble of trajectories </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opt</td><td>Option for selecting the way to describe the electron-nuclear interaction: = 0 - Ehrenfest (mean-field, MF), =1 - (fewest switched surface hopping, FSSH)</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the potential energy computed according to the selected option: either the poetial energy of an active electronic level (as given by el variable) - this is for opt = 1 - or the state averaged potential energy (the averaging also accounts for nonadiabatic couplings or off-diagonal Hamiltonian terms) - this is for opt = 0 The computed forces are stored in the mol object</p>
<p>The returned potential energy is also averaged over all trajectories included in the ensemble object ens. No averaging of forces is needed.</p>

</div>
</div>
<a class="anchor" id="aae5b75e151a9a330a8abb73cd9a931f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::compute_hopping_probabilities_esh </td>
          <td>(</td>
          <td class="paramtype">Ensemble &amp;&#160;</td>
          <td class="paramname"><em>ens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_boltz_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the ESH surface hopping probabilities for the trajectory described by mol, el, and ham </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ent</td><td>Describes the ensemble of trajectories that are being propagated </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>The matrix of hopping probabilities </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Time duration of nuclear propagation step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_boltz_factor</td><td>A flag to select the Boltzmann scaling in lieu of hop rejection/velocity rescaling scheme </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>nuclear temperature - used in the Boltzmann factor - only if use_boltz_factor is set to 1</td></tr>
  </table>
  </dd>
</dl>
<p>Assume ham internal processings are done outside Assume matrix g is allocated</p>
<p>Abbreviation: ESH - entangled surface hopping</p>
<p>IMPORTANT!!! This is my experimental approach - trying to determine the surface hopping probabilities based on the properties of all trajectories - this is done by averaging some terms that enter computation of hopping probabilities</p>
<p>Don't use this method unless you make it work. The main idea behind this block so far is to use it as a template/placeholder for implementing different entngled SH methods</p>

</div>
</div>
<a class="anchor" id="a2fa1062947434817b4ac00b3845348e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> liblibra::libdyn::compute_hopping_probabilities_fssh </td>
          <td>(</td>
          <td class="paramtype">CMATRIX &amp;&#160;</td>
          <td class="paramname"><em>Coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX &amp;&#160;</td>
          <td class="paramname"><em>Hvib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1e73a64ac17d4e92a774e4c51d4b9ea6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::compute_hopping_probabilities_fssh </td>
          <td>(</td>
          <td class="paramtype">Nuclear *&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Electronic *&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hamiltonian *&#160;</td>
          <td class="paramname"><em>ham</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_boltz_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the FSSH surface hopping probabilities for the trajectory described by mol, el, and ham </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mol</td><td>Describes the nuclear DOF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">el</td><td>Describes electronic DOF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ham</td><td>Is the Hamiltonian object that works as a functor (takes care of all calculations of given type) -its internal variables are changed during the compuations </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>The matrix of hopping probabilities </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Time duration of nuclear propagation step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_boltz_factor</td><td>A flag to select the Boltzmann scaling in lieu of hop rejection/velocity rescaling scheme </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>nuclear temperature - used in the Boltzmann factor - only if use_boltz_factor is set to 1</td></tr>
  </table>
  </dd>
</dl>
<p>Assume ham internal processings are done outside Assume matrix g is allocated</p>
<p>Abbreviation: FSSH - fewest switches surface hopping References: (1) Tully, J. C. Molecular Dynamics with Electronic Transitions. J. Chem. Phys. 1990, 93, 10611071. - the original paper (2) Fabiano, E.; Keal, T. W.; Thiel, W. Implementation of Surface Hopping Molecular Dynamics Using Semiempirical Methods. Chem. Phys. 2008, 349, 334347. Here, we generalized the formula, so it works equally well for both diabatic and adiabatic representations</p>

</div>
</div>
<a class="anchor" id="a1e27a4e93a7a23ba9277d9faf7a4a119"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::compute_hopping_probabilities_fssh </td>
          <td>(</td>
          <td class="paramtype">Nuclear &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Electronic &amp;&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hamiltonian &amp;&#160;</td>
          <td class="paramname"><em>ham</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_boltz_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the FSSH surface hopping probabilities for the trajectory described by mol, el, and ham - Python-friendly </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mol</td><td>Describes the nuclear DOF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">el</td><td>Describes electronic DOF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ham</td><td>Is the Hamiltonian object that works as a functor (takes care of all calculations of given type) -its internal variables are changed during the compuations </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>The matrix of hopping probabilities </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Time duration of nuclear propagation step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_boltz_factor</td><td>A flag to select the Boltzmann scaling in lieu of hop rejection/velocity rescaling scheme </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>nuclear temperature - used in the Boltzmann factor - only if use_boltz_factor is set to 1</td></tr>
  </table>
  </dd>
</dl>
<p>Assume ham internal processings are done outside Assume matrix g is allocated</p>
<p>Abbreviation: FSSH - fewest switches surface hopping References: (1) Tully, J. C. Molecular Dynamics with Electronic Transitions. J. Chem. Phys. 1990, 93, 10611071. - the original paper (2) Fabiano, E.; Keal, T. W.; Thiel, W. Implementation of Surface Hopping Molecular Dynamics Using Semiempirical Methods. Chem. Phys. 2008, 349, 334347. Here, we generalized the formula, so it works equally well for both diabatic and adiabatic representations</p>

</div>
</div>
<a class="anchor" id="a949e0aa843a01adb9d958d8cd12f7cc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::compute_hopping_probabilities_fssh </td>
          <td>(</td>
          <td class="paramtype">Ensemble &amp;&#160;</td>
          <td class="paramname"><em>ens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_boltz_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the FSSH surface hopping probabilities for a selected trajectory of an ensemble - Python friendly </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ens</td><td>Describes the ensemble of trajectories </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Is the index of the trajectory of interest </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>The matrix of hopping probabilities for this tranjectory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Time duration of nuclear propagation step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_boltz_factor</td><td>A flag to select the Boltzmann scaling in lieu of hop rejection/velocity rescaling scheme </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>nuclear temperature - used in the Boltzmann factor - only if use_boltz_factor is set to 1</td></tr>
  </table>
  </dd>
</dl>
<p>Assume ham internal processings are done outside Assume matrix g is allocated</p>
<p>Abbreviation: FSSH - fewest switches surface hopping References: (1) Tully, J. C. Molecular Dynamics with Electronic Transitions. J. Chem. Phys. 1990, 93, 10611071. - the original paper (2) Fabiano, E.; Keal, T. W.; Thiel, W. Implementation of Surface Hopping Molecular Dynamics Using Semiempirical Methods. Chem. Phys. 2008, 349, 334347. Here, we generalized the formula, so it works equally well for both diabatic and adiabatic representations</p>

</div>
</div>
<a class="anchor" id="a79d5e94d410b43db896244ddfccd0c7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> liblibra::libdyn::compute_hopping_probabilities_gfsh </td>
          <td>(</td>
          <td class="paramtype">CMATRIX &amp;&#160;</td>
          <td class="paramname"><em>Coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX &amp;&#160;</td>
          <td class="paramname"><em>Hvib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the GFSH surface hopping probabilities for the trajectory described by mol, el, and ham </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Coeff</td><td>Wavefunction amplitudes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Hvib</td><td>vibronic Hamiltonian matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Time duration of nuclear propagation step</td></tr>
  </table>
  </dd>
</dl>
<p>Abbreviation: GFSH - global flux surface hopping References: (1) Wang, L.; Trivedi, D.; Prezhdo, O. V. Global Flux Surface Hopping Approach for Mixed Quantum-Classical Dynamics. J. Chem. Theory Comput. 2014, 10, 35983605.</p>

</div>
</div>
<a class="anchor" id="a6004f3b0aa54c03e0f0384d51d38a464"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::compute_hopping_probabilities_gfsh </td>
          <td>(</td>
          <td class="paramtype">Nuclear *&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Electronic *&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hamiltonian *&#160;</td>
          <td class="paramname"><em>ham</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_boltz_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the GFSH surface hopping probabilities for the trajectory described by mol, el, and ham </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mol</td><td>Describes the nuclear DOF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">el</td><td>Describes electronic DOF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ham</td><td>Is the Hamiltonian object that works as a functor (takes care of all calculations of given type) -its internal variables are changed during the compuations </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>The matrix of hopping probabilities </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Time duration of nuclear propagation step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_boltz_factor</td><td>A flag to select the Boltzmann scaling in lieu of hop rejection/velocity rescaling scheme </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>nuclear temperature - used in the Boltzmann factor - only if use_boltz_factor is set to 1</td></tr>
  </table>
  </dd>
</dl>
<p>Assume ham internal processings are done outside Assume matrix g is allocated</p>
<p>Abbreviation: GFSH - global flux surface hopping References: (1) Wang, L.; Trivedi, D.; Prezhdo, O. V. Global Flux Surface Hopping Approach for Mixed Quantum-Classical Dynamics. J. Chem. Theory Comput. 2014, 10, 35983605.</p>

</div>
</div>
<a class="anchor" id="a431a97197960b04631bc5e0878b3a118"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::compute_hopping_probabilities_gfsh </td>
          <td>(</td>
          <td class="paramtype">Nuclear &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Electronic &amp;&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hamiltonian &amp;&#160;</td>
          <td class="paramname"><em>ham</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_boltz_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the GFSH surface hopping probabilities for the trajectory described by mol, el, and ham - Python-friendly </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mol</td><td>Describes the nuclear DOF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">el</td><td>Describes electronic DOF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ham</td><td>Is the Hamiltonian object that works as a functor (takes care of all calculations of given type) -its internal variables are changed during the compuations </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>The matrix of hopping probabilities </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Time duration of nuclear propagation step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_boltz_factor</td><td>A flag to select the Boltzmann scaling in lieu of hop rejection/velocity rescaling scheme </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>nuclear temperature - used in the Boltzmann factor - only if use_boltz_factor is set to 1</td></tr>
  </table>
  </dd>
</dl>
<p>Assume ham internal processings are done outside Assume matrix g is allocated</p>
<p>Abbreviation: GFSH - global flux surface hopping References: (1) Wang, L.; Trivedi, D.; Prezhdo, O. V. Global Flux Surface Hopping Approach for Mixed Quantum-Classical Dynamics. J. Chem. Theory Comput. 2014, 10, 35983605.</p>

</div>
</div>
<a class="anchor" id="a432545e27a8b47653a0ace1c7cf154d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::compute_hopping_probabilities_gfsh </td>
          <td>(</td>
          <td class="paramtype">Ensemble &amp;&#160;</td>
          <td class="paramname"><em>ens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_boltz_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the GFSH surface hopping probabilities for a selected trajectory of an ensemble - Python friendly </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ens</td><td>Describes the ensemble of trajectories </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Is the index of the trajectory of interest </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>The matrix of hopping probabilities for this tranjectory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Time duration of nuclear propagation step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_boltz_factor</td><td>A flag to select the Boltzmann scaling in lieu of hop rejection/velocity rescaling scheme </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>nuclear temperature - used in the Boltzmann factor - only if use_boltz_factor is set to 1</td></tr>
  </table>
  </dd>
</dl>
<p>Assume ham internal processings are done outside Assume matrix g is allocated</p>
<p>Abbreviation: GFSH - global flux surface hopping References: (1) Wang, L.; Trivedi, D.; Prezhdo, O. V. Global Flux Surface Hopping Approach for Mixed Quantum-Classical Dynamics. J. Chem. Theory Comput. 2014, 10, 35983605.</p>

</div>
</div>
<a class="anchor" id="aa232f18b1a993a1a99820ef687eaa53a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> liblibra::libdyn::compute_hopping_probabilities_mssh </td>
          <td>(</td>
          <td class="paramtype">CMATRIX &amp;&#160;</td>
          <td class="paramname"><em>Coeff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the MSSH surface hopping probabilities for the trajectory described by the coefficients Coeff</p>
<p>This is the version taking the minimal amount of input information</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Coeff</td><td>The amplitudes of different basis states in the coherent superposition. This matrix is assumed to be a column-vector, so of the size N x 1, where N is the number of basis excited states</td></tr>
  </table>
  </dd>
</dl>
<p>The function returns the matrix g with hopping probabilities</p>
<p>Abbreviation: MSSH - Markov state surface hopping References: (1) Akimov, A. V.; Trivedi, D.; Wang, L.; Prezhdo, O. V. Analysis of the Trajectory Surface Hopping Method from the Markov State Model Perspective. J. Phys. Soc. Jpn. 2015, 84, 094002.</p>

</div>
</div>
<a class="anchor" id="a7d7771b115bf8783c8bef0f85748f5b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::compute_hopping_probabilities_mssh </td>
          <td>(</td>
          <td class="paramtype">Nuclear *&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Electronic *&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hamiltonian *&#160;</td>
          <td class="paramname"><em>ham</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_boltz_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the MSSH surface hopping probabilities for the trajectory described by mol, el, and ham </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mol</td><td>Describes the nuclear DOF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">el</td><td>Describes electronic DOF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ham</td><td>Is the Hamiltonian object that works as a functor (takes care of all calculations of given type) -its internal variables are changed during the compuations </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>The matrix of hopping probabilities </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Time duration of nuclear propagation step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_boltz_factor</td><td>A flag to select the Boltzmann scaling in lieu of hop rejection/velocity rescaling scheme </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>nuclear temperature - used in the Boltzmann factor - only if use_boltz_factor is set to 1</td></tr>
  </table>
  </dd>
</dl>
<p>Assume ham internal processings are done outside Assume matrix g is allocated</p>
<p>Abbreviation: MSSH - Markov state surface hopping References: (1) Akimov, A. V.; Trivedi, D.; Wang, L.; Prezhdo, O. V. Analysis of the Trajectory Surface Hopping Method from the Markov State Model Perspective. J. Phys. Soc. Jpn. 2015, 84, 094002.</p>

</div>
</div>
<a class="anchor" id="a213d0cefa7bb0481849ad9ed16b13c47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::compute_hopping_probabilities_mssh </td>
          <td>(</td>
          <td class="paramtype">Nuclear &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Electronic &amp;&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hamiltonian &amp;&#160;</td>
          <td class="paramname"><em>ham</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_boltz_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the MSSH surface hopping probabilities for the trajectory described by mol, el, and ham - Python-friendly </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mol</td><td>Describes the nuclear DOF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">el</td><td>Describes electronic DOF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ham</td><td>Is the Hamiltonian object that works as a functor (takes care of all calculations of given type) -its internal variables are changed during the compuations </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>The matrix of hopping probabilities </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Time duration of nuclear propagation step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_boltz_factor</td><td>A flag to select the Boltzmann scaling in lieu of hop rejection/velocity rescaling scheme </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>nuclear temperature - used in the Boltzmann factor - only if use_boltz_factor is set to 1</td></tr>
  </table>
  </dd>
</dl>
<p>Assume ham internal processings are done outside Assume matrix g is allocated</p>
<p>Abbreviation: MSSH - Markov state surface hopping References: (1) Akimov, A. V.; Trivedi, D.; Wang, L.; Prezhdo, O. V. Analysis of the Trajectory Surface Hopping Method from the Markov State Model Perspective. J. Phys. Soc. Jpn. 2015, 84, 094002.</p>

</div>
</div>
<a class="anchor" id="a6c4c024ac2fb01e12b444a5eaaf32ac3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::compute_hopping_probabilities_mssh </td>
          <td>(</td>
          <td class="paramtype">Ensemble &amp;&#160;</td>
          <td class="paramname"><em>ens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_boltz_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the MSSH surface hopping probabilities for a selected trajectory of an ensemble - Python friendly </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ens</td><td>Describes the ensemble of trajectories </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Is the index of the trajectory of interest </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>The matrix of hopping probabilities for this tranjectory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Time duration of nuclear propagation step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_boltz_factor</td><td>A flag to select the Boltzmann scaling in lieu of hop rejection/velocity rescaling scheme </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>nuclear temperature - used in the Boltzmann factor - only if use_boltz_factor is set to 1</td></tr>
  </table>
  </dd>
</dl>
<p>Assume ham internal processings are done outside Assume matrix g is allocated</p>
<p>Abbreviation: MSSH - Markov state surface hopping References: (1) Akimov, A. V.; Trivedi, D.; Wang, L.; Prezhdo, O. V. Analysis of the Trajectory Surface Hopping Method from the Markov State Model Perspective. J. Phys. Soc. Jpn. 2015, 84, 094002.</p>

</div>
</div>
<a class="anchor" id="a57f1be44f239fbdb9613cb93ba163a1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double liblibra::libdyn::compute_kinetic_energy </td>
          <td>(</td>
          <td class="paramtype">Nuclear *&#160;</td>
          <td class="paramname"><em>mol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute kinetic energy of Nuclear object </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mol</td><td>The pointer to the Nuclear DOF object</td></tr>
  </table>
  </dd>
</dl>
<p>This is the classical nuclear kinetic energy</p>

</div>
</div>
<a class="anchor" id="ab3274a92a79391a7d0380cdea036253f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double liblibra::libdyn::compute_kinetic_energy </td>
          <td>(</td>
          <td class="paramtype">Nuclear &amp;&#160;</td>
          <td class="paramname"><em>mol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute kinetic energy of Nuclear object - Python-friendly </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mol</td><td>The reference to the Nuclear DOF object</td></tr>
  </table>
  </dd>
</dl>
<p>This is the classical nuclear kinetic energy</p>

</div>
</div>
<a class="anchor" id="aaed0087c124682f82858dd0baad6f511"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double liblibra::libdyn::compute_kinetic_energy </td>
          <td>(</td>
          <td class="paramtype">Ensemble &amp;&#160;</td>
          <td class="paramname"><em>ens</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute average kinetic energy of an ensemble of Nuclear objects - Python-friendly </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ens</td><td>The reference to the Ensemble object</td></tr>
  </table>
  </dd>
</dl>
<p>This is the classical nuclear kinetic energy</p>

</div>
</div>
<a class="anchor" id="a023501af48d4c56a7124a5f4da477db8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double liblibra::libdyn::compute_potential_energy </td>
          <td>(</td>
          <td class="paramtype">Nuclear *&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Electronic *&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hamiltonian *&#160;</td>
          <td class="paramname"><em>ham</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute potential energy of a quantum-classical system </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mol</td><td>Describes the nuclear DOF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">el</td><td>Describes electronic DOF </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ham</td><td>Is the Hamiltonian object that works as a functor (takes care of all calculations of given type) -its internal variables are changed during the compuations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opt</td><td>Option for selecting the way to describe the electron-nuclear interaction: = 0 - Ehrenfest (mean-field, MF), =1 - (fewest switched surface hopping, FSSH)</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the potential energy computed according to the selected option: either the poetial energy of an active electronic level (as given by el variable) - this is for opt = 1 - or the state averaged potential energy (the averaging also accounts for nonadiabatic couplings or off-diagonal Hamiltonian terms) - this is for opt = 0</p>

</div>
</div>
<a class="anchor" id="adae8cc29e5622a80dc3e4c26944d55ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double liblibra::libdyn::compute_potential_energy </td>
          <td>(</td>
          <td class="paramtype">Nuclear &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Electronic &amp;&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hamiltonian &amp;&#160;</td>
          <td class="paramname"><em>ham</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute potential energy of a quantum-classical system - Python-friendly </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mol</td><td>Describes the nuclear DOF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">el</td><td>Describes electronic DOF </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ham</td><td>Is the Hamiltonian object that works as a functor (takes care of all calculations of given type) -its internal variables are changed during the compuations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opt</td><td>Option for selecting the way to describe the electron-nuclear interaction: = 0 - Ehrenfest (mean-field, MF), =1 - (fewest switched surface hopping, FSSH)</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the potential energy computed according to the selected option: either the poetial energy of an active electronic level (as given by el variable) - this is for opt = 1 - or the state averaged potential energy (the averaging also accounts for nonadiabatic couplings or off-diagonal Hamiltonian terms) - this is for opt = 0</p>

</div>
</div>
<a class="anchor" id="a76ad9f5bd839e78fda590d11575ae8d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double liblibra::libdyn::compute_potential_energy </td>
          <td>(</td>
          <td class="paramtype">Ensemble &amp;&#160;</td>
          <td class="paramname"><em>ens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute potential energy of a quantum-classical system - Python-friendly </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ens</td><td>The reference to the ensemble of trajectories </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opt</td><td>Option for selecting the way to describe the electron-nuclear interaction: = 0 - Ehrenfest (mean-field, MF), =1 - (fewest switched surface hopping, FSSH)</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the potential energy computed according to the selected option: either the poetial energy of an active electronic level (as given by el variable) - this is for opt = 1 - or the state averaged potential energy (the averaging also accounts for nonadiabatic couplings or off-diagonal Hamiltonian terms) - this is for opt = 0</p>
<p>The returned potential energy is also averaged over all trajectories included in the ensemble object ens.</p>

</div>
</div>
<a class="anchor" id="adaa4f65b0b719f456c57a7c29dd48101"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int liblibra::libdyn::dish </td>
          <td>(</td>
          <td class="paramtype">Electronic &amp;&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX &amp;&#160;</td>
          <td class="paramname"><em>t_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MATRIX &amp;&#160;</td>
          <td class="paramname"><em>tau_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CMATRIX &amp;&#160;</td>
          <td class="paramname"><em>Hvib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_boltz_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Ekin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ksi1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ksi2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decoherence-induced surface hopping (DISH)</p>
<p>Reference: Jaeger, H. M.; Fischer, S.; Prezhdo, O. V. Decoherence-Induced Surface Hopping. J. Chem. Phys. 2012, 137, 22A545.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">el</td><td>Electronic object, containing the info about electronic amplitudes </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">t_m</td><td>A matrix N x 1 of the times each state resides in a coherence interval (since the last decoherence event) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau_m</td><td>A matrix N x 1 of the coherence intervals for each electronic state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Hvib</td><td>The matrix of vibronic Hamiltonian - we need the energies </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_boltz_flag</td><td>if set to 1, the hopping probabilities will be re-scaled by the Boltzmann factor. This is need in neglect of back-reaction approximation (NBRA) calculations, when no </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ekin</td><td>Kinetic energy of nuclei </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>is the temperature of the system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ksi1</td><td>a is random number from a uniform distribution on the [0,1] interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ksi2</td><td>a is random number from a uniform distribution on the [0,1] interval</td></tr>
  </table>
  </dd>
</dl>
<p>The function modifies el and t_m variables Returns: the index of the electronic state after potential hop</p>
<p>set to 1 if we have already encountered a decoherence event</p>
<p>The state i has evolved coherently for longer than the coherence interval so it has to experience a decoherence event</p>
<p>There are essentially two outcomes when the decoherence takes place: One: we collapse the wavefunction onto the state i with the probability given by the population of that state</p>
<p>Now, lets determine if the hop is possible based on the energy conservation considerations</p>
<p>initial potential energy</p>
<p>proposed potential energy</p>
<p>In leu of hop rejection use Boltzmann factors: for NBRA simulations</p>
<p>hop to higher energy state is difficult</p>
<p>hop is allowed thermally</p>
<p>Regular energy-conservation based criterion</p>
<p>Predicted final kinetic energy is positive - hop is possible</p>
<p>Now, decide about decoherence</p>
<p>Here is the actuall collapse</p>
<p>Second: project the system out of that state otherwise</p>
<p>Reset the time axis for state i (only for this state) other states still reside in a coherent superposition</p>
<p>Set the flag that we have attempted a decoherence event so we done with DISH at this point in time </p>

</div>
</div>
<a class="anchor" id="a25d1338a4ed5df78408e3bb7905806fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int liblibra::libdyn::dish </td>
          <td>(</td>
          <td class="paramtype">Electronic &amp;&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Nuclear &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hamiltonian &amp;&#160;</td>
          <td class="paramname"><em>ham</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX &amp;&#160;</td>
          <td class="paramname"><em>t_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MATRIX &amp;&#160;</td>
          <td class="paramname"><em>tau_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_boltz_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ksi1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ksi2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decoherence-induced surface hopping (DISH) - overloaded version</p>
<p>Reference: Jaeger, H. M.; Fischer, S.; Prezhdo, O. V. Decoherence-Induced Surface Hopping. J. Chem. Phys. 2012, 137, 22A545.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">el</td><td>Electronic object, containing the info about electronic amplitudes </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">t_m</td><td>A matrix N x 1 of the times each state resides in a coherence interval (since the last decoherence event) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau_m</td><td>A matrix N x 1 of the coherence intervals for each electronic state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Hvib</td><td>The matrix of vibronic Hamiltonian - we need the energies </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_boltz_flag</td><td>if set to 1, the hopping probabilities will be re-scaled by the Boltzmann factor. This is need in neglect of back-reaction approximation (NBRA) calculations, when no </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ekin</td><td>Kinetic energy of nuclei </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>is the temperature of the system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ksi1</td><td>a is random number from a uniform distribution on the [0,1] interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ksi2</td><td>a is random number from a uniform distribution on the [0,1] interval</td></tr>
  </table>
  </dd>
</dl>
<p>The function modifies el and t_m variables Returns: the index of the electronic state after potential hop</p>
<p>set to 1 if we have already encountered a decoherence event</p>
<p>The state i has evolved coherently for longer than the coherence interval so it has to experience a decoherence event</p>
<p>There are essentially two outcomes when the decoherence takes place: One: we collapse the wavefunction onto the state i with the probability given by the population of that state</p>
<p>Now, lets determine if the hop is possible based on the energy conservation considerations</p>
<p>initial potential energy</p>
<p>proposed potential energy</p>
<p>In leu of hop rejection use Boltzmann factors: for NBRA simulations</p>
<p>hop to higher energy state is difficult</p>
<p>hop is allowed thermally</p>
<p>Regular energy-conservation based criterion</p>
<p>Predicted final kinetic energy is positive - hop is possible</p>
<p>Now, decide about decoherence</p>
<p>Here is the actuall collapse</p>
<p>Second: project the system out of that state otherwise</p>
<p>Reset the time axis for state i (only for this state) other states still reside in a coherent superposition</p>
<p>Set the flag that we have attempted a decoherence event so we done with DISH at this point in time </p>

</div>
</div>
<a class="anchor" id="aac46175ec66d05aea89ed38be47e3ff1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::export_Dyn_objects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exporter of libdyn classes and functions</p>

</div>
</div>
<a class="anchor" id="ad915d6355d45091809d1e3b8a72ce3da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int liblibra::libdyn::hop </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>initstate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ksi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempts a stochastic hop from the initial state "initstate" </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">initstate</td><td>The index of the state from which we try to hop out </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>The hopping probabilities matrix (type MATRIX) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ksi</td><td>A random number that determines the outcome of the "hop" procedure</td></tr>
  </table>
  </dd>
</dl>
<p>Returned value: the index of the state to which we have hopped</p>

</div>
</div>
<a class="anchor" id="a69a84d6f7347afd1f299633c9ef80030"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::hop </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>initstate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Nuclear *&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hamiltonian *&#160;</td>
          <td class="paramname"><em>ham</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ksi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>do_rescaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>do_reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do actual hop from the state initstate </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">initstate</td><td>The state from which we try to hop out - it will also be updated after the hop has happened </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mol</td><td>Nuclear DOF. Can be updated (velocity rescaling or reversal) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ham</td><td>A handler of Hamiltonian. Internal parameters may be updated, if the Hamiltonian is recomputed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ksi</td><td>A random number that determines the outcome of the "hop" procedure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>The hopping probabilities matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">do_rescaling</td><td>The flag to turn on/off CPA: 0 - no velocity rescaling (CPA, no back-reaction), in this case one should use Boltzmann factor (consider use_boltz_factor when computing the hopping probability matrix, g) 1 - do rescaling (back-reaction), in this case it would be wrong to use Boltzmann factor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rep</td><td>Selects the used representation: 0 - for diabatic, 1 - for adiabatic </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">do_reverse</td><td>The option that determines what to do if the hop was rejected because of the energy conservation (frustrated hop): do_reverse = 0 - nuclear momenta(velocities) stay unchanged; do_reverse = 1 - nuclear momenta(velocities) are inverted.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d902216782095d624d55231e022ea55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int liblibra::libdyn::hop </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>initstate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Nuclear &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hamiltonian &amp;&#160;</td>
          <td class="paramname"><em>ham</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ksi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>do_rescaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>do_reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do actual hop from the state initstate - Python-friendly </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">initstate</td><td>The state from which we try to hop out - it will also be updated after the hop has happened </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mol</td><td>Nuclear DOF. Can be updated (velocity rescaling or reversal) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ham</td><td>A handler of Hamiltonian. Internal parameters may be updated, if the Hamiltonian is recomputed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ksi</td><td>A random number that determines the outcome of the "hop" procedure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>The hopping probabilities matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">do_rescaling</td><td>The flag to turn on/off CPA: 0 - no velocity rescaling (CPA, no back-reaction), in this case one should use Boltzmann factor (consider use_boltz_factor when computing the hopping probability matrix, g) 1 - do rescaling (back-reaction), in this case it would be wrong to use Boltzmann factor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rep</td><td>Selects the used representation: 0 - for diabatic, 1 - for adiabatic </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">do_reverse</td><td>The option that determines what to do if the hop was rejected because of the energy conservation (frustrated hop): do_reverse = 0 - nuclear momenta(velocities) stay unchanged; do_reverse = 1 - nuclear momenta(velocities) are inverted.</td></tr>
  </table>
  </dd>
</dl>
<p>The function returns the index of the final state (new or old).</p>

</div>
</div>
<a class="anchor" id="a80700eaa7d1da741f206c73fd4e95193"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int liblibra::libdyn::hop </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>initstate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ensemble &amp;&#160;</td>
          <td class="paramname"><em>ens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ksi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>do_rescaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>do_reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do actual hop from the state initstate of the i-th trajectory of an ensemble - Python-friendly </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">initstate</td><td>The state from which we try to hop out - it will also be updated after the hop has happened </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The index of the trajectory of interest </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ens</td><td>Describes the ensemble of trajectories which we propagate (including hops) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ksi</td><td>A random number that determines the outcome of the "hop" procedure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>The hopping probabilities matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">do_rescaling</td><td>The flag to turn on/off CPA: 0 - no velocity rescaling (CPA, no back-reaction), in this case one should use Boltzmann factor (consider use_boltz_factor when computing the hopping probability matrix, g) 1 - do rescaling (back-reaction), in this case it would be wrong to use Boltzmann factor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rep</td><td>Selects the used representation: 0 - for diabatic, 1 - for adiabatic </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">do_reverse</td><td>The option that determines what to do if the hop was rejected because of the energy conservation (frustrated hop): do_reverse = 0 - nuclear momenta(velocities) stay unchanged; do_reverse = 1 - nuclear momenta(velocities) are inverted.</td></tr>
  </table>
  </dd>
</dl>
<p>The function returns the index of the final state (new or old).</p>

</div>
</div>
<a class="anchor" id="ad8135a783124f7db594c46fd4d8e0e7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int liblibra::libdyn::ida </td>
          <td>(</td>
          <td class="paramtype">CMATRIX &amp;&#160;</td>
          <td class="paramname"><em>Coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>old_st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>E_old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>E_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ksi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instantaneous decoherence at attempted hops (ID-A)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Coeff</td><td>The matrix of coefficients (amplitudes of the basis excited states). This matrix is modified at every decoherence event </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_st</td><td>The old state before an attempted hop </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_st</td><td>The new state after an attempted hop (no matter what the algorithm - FSSH, GFSH, MSSH, or something else) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E_old</td><td>The energy corresponding to the old state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E_new</td><td>The energy corresponding to the new state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>is the temperature of the system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ksi</td><td>a random number from a uniform distribution of the [0,1] interval - needed to decide the hop acceptance/decoherence</td></tr>
  </table>
  </dd>
</dl>
<p>The function returns the index of the new state after hop rejection/decoherence criteria The function also modifies the amplitudes of the coherent superposition</p>

</div>
</div>
<a class="anchor" id="ae5f77aff460464653b3e1a12dba4548c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::propagate_ensemble </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ensemble *&#160;</td>
          <td class="paramname"><em>ens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Propagate nuclear and electronic DOF for an ensemble of trajectories </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Integration time step (evolution duration) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ens</td><td>The pointer to the Ensemble object state of which is being propagated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opt</td><td>Option for selecting the way to describe the electron-nuclear interaction: = 0 - Ehrenfest (mean-field, MF), =1 - (fewest switched surface hopping, FSSH)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7efcecf345f89cb24be4c3d1af8fb18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::propagate_ensemble </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ensemble &amp;&#160;</td>
          <td class="paramname"><em>ens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Propagate nuclear and electronic DOF for an ensemble of trajectories - Python-friendly </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Integration time step (evolution duration) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ens</td><td>The Ensemble object state of which is being propagated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opt</td><td>Option for selecting the way to describe the electron-nuclear interaction: = 0 - Ehrenfest (mean-field, MF), =1 - (fewest switched surface hopping, FSSH)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f262f1444a5ee18b6713c930eec7c71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::propagate_nuclear </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Nuclear *&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Electronic *&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hamiltonian *&#160;</td>
          <td class="paramname"><em>ham</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>One step of Velocity verlet algorithm for nuclear DOF </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Integration</td><td>time step </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mol</td><td>Describes the nuclear DOF. Changes during the integration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">el</td><td>Describes electronic DOF. Does not change during the integration. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ham</td><td>Is the Hamiltonian object that works as a functor (takes care of all calculations of given type) -its internal variables are changed during the compuations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opt</td><td>Option for selecting the way to describe the electron-nuclear interaction: = 0 - Ehrenfest (mean-field, MF), =1 - (fewest switched surface hopping, FSSH)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af8cc179f143d4167bb8b8df0cb523b8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::propagate_nuclear </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Nuclear *&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Electronic *&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hamiltonian *&#160;</td>
          <td class="paramname"><em>ham</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Thermostat *&#160;</td>
          <td class="paramname"><em>therm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>One step of Velocity verlet algorithm coupled to nuclear Thermostat - for NVT calculations !!! IMPORTANT: Presently, this is only a template - the thermostat part is only outlined - need to test this first !!!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Integration</td><td>time step </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mol</td><td>Describes the nuclear DOF. Changes during the integration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">el</td><td>Describes electronic DOF. Does not change during the integration. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ham</td><td>Is the Hamiltonian object that works as a functor (takes care of all calculations of given type) -its internal variables are changed during the compuations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">therm</td><td>The pointer to a Thermostat object, which contains the information about thermal bath state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opt</td><td>Option for selecting the way to describe the electron-nuclear interaction: = 0 - Ehrenfest (mean-field, MF), =1 - (fewest switched surface hopping, FSSH)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10e448956797c11e694036a4fce34b31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::rescale_velocities_adiabatic </td>
          <td>(</td>
          <td class="paramtype">Nuclear *&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hamiltonian *&#160;</td>
          <td class="paramname"><em>ham</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>new_st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>old_st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>do_reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine whether we need to do velocity rescaling/reversal when going from one state to another </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mol</td><td>Nuclear DOF. Can be updated (velocity rescaling or reversal) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ham</td><td>A handler of Hamiltonian. Internal parameters may be updated, if the Hamiltonian is recomputed </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_st</td><td>The index of the new state: this is a truly new state if the attempted hop was successfull, or just can be an old state, otherwise </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_st</td><td>The index of the old state (from which we try to hop) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">do_reverse</td><td>The option that determines what to do if the hop was rejected because of the energy conservation (frustrated hop): do_reverse = 0 - nuclear momenta(velocities) stay unchanged; do_reverse = 1 - nuclear momenta(velocities) are inverted.</td></tr>
  </table>
  </dd>
</dl>
<p>This verions implies that the adiabatic representation is used</p>

</div>
</div>
<a class="anchor" id="aa9f1ba34575eaaee93f71bab4995c809"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int liblibra::libdyn::rescale_velocities_adiabatic </td>
          <td>(</td>
          <td class="paramtype">Nuclear &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hamiltonian &amp;&#160;</td>
          <td class="paramname"><em>ham</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>old_st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>do_reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine whether we need to do velocity rescaling/reversal when going from one state to another - Python-friendly </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mol</td><td>Nuclear DOF. Can be updated (velocity rescaling or reversal) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ham</td><td>A handler of Hamiltonian. Internal parameters may be updated, if the Hamiltonian is recomputed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_st</td><td>The index of the old state (from which we try to hop) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">do_reverse</td><td>The option that determines what to do if the hop was rejected because of the energy conservation (frustrated hop): do_reverse = 0 - nuclear momenta(velocities) stay unchanged; do_reverse = 1 - nuclear momenta(velocities) are inverted.</td></tr>
  </table>
  </dd>
</dl>
<p>The function returns the index of the new state: this is a truly new state if the attempted hop was successfull, or just can be an old state, otherwise</p>
<p>This verions implies that the adiabatic representation is used</p>

</div>
</div>
<a class="anchor" id="a4853be2a1983134e633fcae0c21dd896"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libdyn::rescale_velocities_diabatic </td>
          <td>(</td>
          <td class="paramtype">Nuclear *&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hamiltonian *&#160;</td>
          <td class="paramname"><em>ham</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>new_st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>old_st</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine whether we need to do velocity rescaling/reversal when going from one state to another </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mol</td><td>Nuclear DOF. Can be updated (velocity rescaling or reversal) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ham</td><td>A handler of Hamiltonian. Internal parameters may be updated, if the Hamiltonian is recomputed </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_st</td><td>The index of the new state: this is a truly new state if the attempted hop was successfull, or just can be an old state, otherwise </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_st</td><td>The index of the old state (from which we try to hop)</td></tr>
  </table>
  </dd>
</dl>
<p>This verions implies that the diabatic representation is used</p>
<p>In this case, derivative couplings are zero by definition of diabatic (position-independent) states so one can not rescale velocities along directions of derivative couplings, since there is no such directions We just scale velocities uniformly - based on energy conservation principle In principle, this rescaling procedure can be applied to surface hopping scheme in adiabatic basis, too</p>

</div>
</div>
<a class="anchor" id="a096dd57779b2a36c054adab74664a063"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int liblibra::libdyn::rescale_velocities_diabatic </td>
          <td>(</td>
          <td class="paramtype">Nuclear &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hamiltonian &amp;&#160;</td>
          <td class="paramname"><em>ham</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>old_st</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine whether we need to do velocity rescaling/reversal when going from one state to another - Python-friendly </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mol</td><td>Nuclear DOF. Can be updated (velocity rescaling or reversal) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ham</td><td>A handler of Hamiltonian. Internal parameters may be updated, if the Hamiltonian is recomputed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_st</td><td>The index of the old state (from which we try to hop)</td></tr>
  </table>
  </dd>
</dl>
<p>The function returns the index of the new state: this is a truly new state if the attempted hop was successfull, or just can be an old state, otherwise</p>
<p>This verions implies that the diabatic representation is used</p>
<p>In this case, derivative couplings are zero by definition of diabatic (position-independent) states so one can not rescale velocities along directions of derivative couplings, since there is no such directions We just scale velocities uniformly - based on energy conservation principle In principle, this rescaling procedure can be applied to surface hopping scheme in adiabatic basis, too</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 25 2017 14:01:31 for Libra by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
