<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Libra: liblibra::libcalculators Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Libra
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceliblibra.html">liblibra</a></li><li class="navelem"><a class="el" href="namespaceliblibra_1_1libcalculators.html">libcalculators</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">liblibra::libcalculators Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>libcalculators namespace  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2ca1c77eb71b4757a13c4dd9b6e5ecd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a2ca1c77eb71b4757a13c4dd9b6e5ecd2">annihilate</a> (int Na, int Nb, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *Pa, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *Pb, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *Ra, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *Rb)</td></tr>
<tr class="separator:a2ca1c77eb71b4757a13c4dd9b6e5ecd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1eb2424ace7d692627f5dfbad5afff9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#ab1eb2424ace7d692627f5dfbad5afff9">annihilate</a> (int Na, int Nb, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *Pa, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *Pb)</td></tr>
<tr class="separator:ab1eb2424ace7d692627f5dfbad5afff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a3f91f582f91cc292f2ad416f53d2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a91a3f91f582f91cc292f2ad416f53d2c">convert_1</a> (boost::python::list bands, vector&lt; pair&lt; int, double &gt; &gt; &amp;int_bands)</td></tr>
<tr class="separator:a91a3f91f582f91cc292f2ad416f53d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda8c673c95b439f5e11e4f35db9889d"><td class="memItemLeft" align="right" valign="top">boost::python::list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#adda8c673c95b439f5e11e4f35db9889d">convert_2</a> (vector&lt; pair&lt; int, double &gt; &gt; &amp;bands)</td></tr>
<tr class="separator:adda8c673c95b439f5e11e4f35db9889d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b90f9c903ecb93e8f07f01fcd6c035"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a80b90f9c903ecb93e8f07f01fcd6c035">order_bands</a> (<a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *E, vector&lt; pair&lt; int, double &gt; &gt; &amp;bands)</td></tr>
<tr class="separator:a80b90f9c903ecb93e8f07f01fcd6c035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4173ec2c134c623cf36e964e1f8b5955"><td class="memItemLeft" align="right" valign="top">boost::python::list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a4173ec2c134c623cf36e964e1f8b5955">order_bands</a> (<a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> E)</td></tr>
<tr class="separator:a4173ec2c134c623cf36e964e1f8b5955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4d2f51ae875643c3e21586b3112c00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a2c4d2f51ae875643c3e21586b3112c00">populate_bands</a> (double Nel, double degen, double kT, double etol, int pop_opt, vector&lt; pair&lt; int, double &gt; &gt; &amp;bands, vector&lt; pair&lt; int, double &gt; &gt; &amp;occ)</td></tr>
<tr class="separator:a2c4d2f51ae875643c3e21586b3112c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed1a5eb32ebb8feec22d13a7bc618d4"><td class="memItemLeft" align="right" valign="top">boost::python::list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a6ed1a5eb32ebb8feec22d13a7bc618d4">populate_bands</a> (double Nel, double degen, double kT, double etol, int pop_opt, boost::python::list bands)</td></tr>
<tr class="separator:a6ed1a5eb32ebb8feec22d13a7bc618d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eecec1eb035e2479331730a69542e8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a0eecec1eb035e2479331730a69542e8b">show_bands</a> (int Norb, int Nocc, vector&lt; pair&lt; int, double &gt; &gt; &amp;bands, vector&lt; pair&lt; int, double &gt; &gt; &amp;occ)</td></tr>
<tr class="separator:a0eecec1eb035e2479331730a69542e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87aab62ca22a49dfd09b9ef7167b8977"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a87aab62ca22a49dfd09b9ef7167b8977">compute_density_matrix</a> (vector&lt; pair&lt; int, double &gt; &gt; &amp;occ, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *C, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *P)</td></tr>
<tr class="separator:a87aab62ca22a49dfd09b9ef7167b8977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d773805b4e811dc1e3cf7b8bd0c5ce3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a1d773805b4e811dc1e3cf7b8bd0c5ce3">compute_density_matrix</a> (vector&lt; pair&lt; int, double &gt; &gt; &amp;occ, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> *C, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> *P)</td></tr>
<tr class="separator:a1d773805b4e811dc1e3cf7b8bd0c5ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13b6c4c284faa77ae369dc03cf05a42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#ac13b6c4c284faa77ae369dc03cf05a42">compute_density_matrix</a> (boost::python::list occ, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> C)</td></tr>
<tr class="separator:ac13b6c4c284faa77ae369dc03cf05a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c777a309a6762efacc7afd2d5f187e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a8c777a309a6762efacc7afd2d5f187e3">compute_density_matrix</a> (boost::python::list occ, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> C)</td></tr>
<tr class="separator:a8c777a309a6762efacc7afd2d5f187e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79df6f0b856d4aa59a7ba5db6ca1aaaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a79df6f0b856d4aa59a7ba5db6ca1aaaf">Fock_to_P</a> (int Norb, int Nocc, int degen, double Nel, std::string eigen_method, int pop_opt, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *Fao, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *Sao, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *C, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *E, vector&lt; pair&lt; int, double &gt; &gt; &amp;bands, vector&lt; pair&lt; int, double &gt; &gt; &amp;occ, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *P, vector&lt; <a class="el" href="classliblibra_1_1Timer.html">Timer</a> &gt; &amp;bench_t)</td></tr>
<tr class="separator:a79df6f0b856d4aa59a7ba5db6ca1aaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd52bf6137a6250210f4c576807dc2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a3bd52bf6137a6250210f4c576807dc2b">Fock_to_P</a> (int Norb, int Nocc, int degen, double Nel, std::string eigen_method, int pop_opt, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> *Fao, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> *Sao, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> *C, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> *E, vector&lt; pair&lt; int, double &gt; &gt; &amp;bands, vector&lt; pair&lt; int, double &gt; &gt; &amp;occ, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> *P, vector&lt; <a class="el" href="classliblibra_1_1Timer.html">Timer</a> &gt; &amp;bench_t)</td></tr>
<tr class="separator:a3bd52bf6137a6250210f4c576807dc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b9b88c75a62459e7010e6eaa00e9ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a25b9b88c75a62459e7010e6eaa00e9ae">Fock_to_P</a> (<a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *Fao, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *Sao, double Nel, double degen, double kT, double etol, int pop_opt, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *E, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *C, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *P, vector&lt; pair&lt; int, double &gt; &gt; &amp;bands, vector&lt; pair&lt; int, double &gt; &gt; &amp;occ, int BM, vector&lt; <a class="el" href="classliblibra_1_1Timer.html">Timer</a> &gt; &amp;bench_t)</td></tr>
<tr class="separator:a25b9b88c75a62459e7010e6eaa00e9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5032fe2892b5d39d1ef7fbfc8784a8ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a5032fe2892b5d39d1ef7fbfc8784a8ce">Fock_to_P</a> (<a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> *Fao, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> *Sao, double Nel, double degen, double kT, double etol, int pop_opt, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> *E, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> *C, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> *P, vector&lt; pair&lt; int, double &gt; &gt; &amp;bands, vector&lt; pair&lt; int, double &gt; &gt; &amp;occ, int BM, vector&lt; <a class="el" href="classliblibra_1_1Timer.html">Timer</a> &gt; &amp;bench_t)</td></tr>
<tr class="separator:a5032fe2892b5d39d1ef7fbfc8784a8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca9a5c855d5780e50f4f7017bf1751a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a4ca9a5c855d5780e50f4f7017bf1751a">Fock_to_P</a> (<a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *Fao, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *Sao, double Nel, double degen, double kT, double etol, int pop_opt, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *E, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *C, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *P, vector&lt; pair&lt; int, double &gt; &gt; &amp;bands, vector&lt; pair&lt; int, double &gt; &gt; &amp;occ)</td></tr>
<tr class="separator:a4ca9a5c855d5780e50f4f7017bf1751a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88932eee16691eec40bc93a06f4d7993"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a88932eee16691eec40bc93a06f4d7993">Fock_to_P</a> (<a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> *Fao, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> *Sao, double Nel, double degen, double kT, double etol, int pop_opt, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> *E, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> *C, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> *P, vector&lt; pair&lt; int, double &gt; &gt; &amp;bands, vector&lt; pair&lt; int, double &gt; &gt; &amp;occ)</td></tr>
<tr class="separator:a88932eee16691eec40bc93a06f4d7993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab578b59ca6c45b60fa21f5dee6889e2e"><td class="memItemLeft" align="right" valign="top">boost::python::list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#ab578b59ca6c45b60fa21f5dee6889e2e">Fock_to_P</a> (<a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> Fao, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> Sao, double Nel, double degen, double kT, double etol, int pop_opt)</td></tr>
<tr class="separator:ab578b59ca6c45b60fa21f5dee6889e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10afb78ccc7278e1f5b8c3f52e60ca7b"><td class="memItemLeft" align="right" valign="top">boost::python::list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a10afb78ccc7278e1f5b8c3f52e60ca7b">Fock_to_P</a> (<a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> Fao, <a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> Sao, double Nel, double degen, double kT, double etol, int pop_opt)</td></tr>
<tr class="separator:a10afb78ccc7278e1f5b8c3f52e60ca7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29ddbbfcd0a7e84e9b1cc24f66fa589"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#ae29ddbbfcd0a7e84e9b1cc24f66fa589">energy_elec</a> (<a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *Pao, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *Hao, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *Fao)</td></tr>
<tr class="separator:ae29ddbbfcd0a7e84e9b1cc24f66fa589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef10eb37546791c1581902293f6d371"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a0ef10eb37546791c1581902293f6d371">energy_elec</a> (<a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> Pao, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> Hao, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> Fao)</td></tr>
<tr class="separator:a0ef10eb37546791c1581902293f6d371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af404ad14cdd3651d7602fa35cec13f3e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#af404ad14cdd3651d7602fa35cec13f3e">energy_elec</a> (<a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *P_alp, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *P_bet, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *Hao_alp, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *Hao_bet, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *Fao_alp, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *Fao_bet, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *dFao_alp_dP_alp, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *dFao_alp_dP_bet, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *dFao_bet_dP_alp, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *dFao_bet_dP_bet, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *temp)</td></tr>
<tr class="separator:af404ad14cdd3651d7602fa35cec13f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3bd75e6ac8d1636c8093627bce35eb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a6d3bd75e6ac8d1636c8093627bce35eb">energy_elec</a> (<a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> P_alp, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> P_bet, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> Hao_alp, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> Hao_bet, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> Fao_alp, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> Fao_bet, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> dFao_alp_dP_alp, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> dFao_alp_dP_bet, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> dFao_bet_dP_alp, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> dFao_bet_dP_bet, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> temp)</td></tr>
<tr class="separator:a6d3bd75e6ac8d1636c8093627bce35eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3627722b83a86e3658dbdf53530101d5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a3627722b83a86e3658dbdf53530101d5">energy_nucl</a> (vector&lt; <a class="el" href="classliblibra_1_1liblinalg_1_1VECTOR.html">VECTOR</a> &gt; &amp;R, vector&lt; double &gt; &amp;Zeff)</td></tr>
<tr class="separator:a3627722b83a86e3658dbdf53530101d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fabf63eac56f6c77adef986b08a370f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a6fabf63eac56f6c77adef986b08a370f">energy_nucl</a> (vector&lt; <a class="el" href="classliblibra_1_1liblinalg_1_1VECTOR.html">VECTOR</a> &gt; &amp;R, vector&lt; double &gt; &amp;Zeff, vector&lt; <a class="el" href="classliblibra_1_1liblinalg_1_1VECTOR.html">VECTOR</a> &gt; &amp;G)</td></tr>
<tr class="separator:a6fabf63eac56f6c77adef986b08a370f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fe770ee31c4326e5cb1c02aece3c51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#ac3fe770ee31c4326e5cb1c02aece3c51">excite</a> (int I, int J, vector&lt; pair&lt; int, double &gt; &gt; &amp;occ_ini, vector&lt; pair&lt; int, double &gt; &gt; &amp;occ_fin)</td></tr>
<tr class="separator:ac3fe770ee31c4326e5cb1c02aece3c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40c54b5f7ce70ae0844ed6baa087500"><td class="memItemLeft" align="right" valign="top">boost::python::list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#ab40c54b5f7ce70ae0844ed6baa087500">excite</a> (int I, int J, boost::python::list occ_ini)</td></tr>
<tr class="separator:ab40c54b5f7ce70ae0844ed6baa087500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af807d367981d69d7b99f0639c98ede65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af807d367981d69d7b99f0639c98ede65"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>excite</b> (int Norb, <a class="el" href="classliblibra_1_1libcommon__types_1_1excitation.html">excitation</a> &amp;ex, int Nocc_alp, vector&lt; pair&lt; int, double &gt; &gt; &amp;occ_alp, int Nocc_bet, vector&lt; pair&lt; int, double &gt; &gt; &amp;occ_bet)</td></tr>
<tr class="separator:af807d367981d69d7b99f0639c98ede65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12732fe06e2dbb44e85e327f9111e20"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#ac12732fe06e2dbb44e85e327f9111e20">fermi_population</a> (double e, double ef, double degen, double kT)</td></tr>
<tr class="separator:ac12732fe06e2dbb44e85e327f9111e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee9c2af406453bf6be966de9b495d05"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a1ee9c2af406453bf6be966de9b495d05">fermi_integral</a> (std::vector&lt; double &gt; &amp;bnds, double ef, double degen, double kT)</td></tr>
<tr class="separator:a1ee9c2af406453bf6be966de9b495d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb0e8685c58bbe27fe34b26a2361ea9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a5bb0e8685c58bbe27fe34b26a2361ea9">fermi_integral</a> (boost::python::list bnds, double ef, double degen, double kT)</td></tr>
<tr class="separator:a5bb0e8685c58bbe27fe34b26a2361ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906ac3f0d2582392ccf7cf43a166003c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a906ac3f0d2582392ccf7cf43a166003c">fermi_energy</a> (std::vector&lt; double &gt; &amp;bnds, double Nel, double degen, double kT, double etol)</td></tr>
<tr class="separator:a906ac3f0d2582392ccf7cf43a166003c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af465db9b9ab0bc13f9e6edac49c9bad4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#af465db9b9ab0bc13f9e6edac49c9bad4">fermi_energy</a> (boost::python::list bnds, double Nel, double degen, double kT, double etol)</td></tr>
<tr class="separator:af465db9b9ab0bc13f9e6edac49c9bad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb0a09044e9439992384c8eb874ca99"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a3eb0a09044e9439992384c8eb874ca99">p_up</a> (double e, double e_up, double de)</td></tr>
<tr class="memdesc:a3eb0a09044e9439992384c8eb874ca99"><td class="mdescLeft">&#160;</td><td class="mdescRight">For FOE: Fermi operator expansion.  <a href="#a3eb0a09044e9439992384c8eb874ca99">More...</a><br/></td></tr>
<tr class="separator:a3eb0a09044e9439992384c8eb874ca99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e6f411d7b8f91a44963e789238bf54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5e6f411d7b8f91a44963e789238bf54"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>p_dn</b> (double e, double e_dn, double de)</td></tr>
<tr class="separator:aa5e6f411d7b8f91a44963e789238bf54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb6e9723d6cd652bae1255e5e022e1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0eb6e9723d6cd652bae1255e5e022e1e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>p_ef</b> (double e, double ef, double de)</td></tr>
<tr class="separator:a0eb6e9723d6cd652bae1255e5e022e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8daca5e7ae412a3f4e53125f99b2f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#aaa8daca5e7ae412a3f4e53125f99b2f1">Chebyshev_coeff</a> (vector&lt; double &gt; &amp;C, double(*f)(double x, double y, double z), double ef, double de, int N)</td></tr>
<tr class="separator:aaa8daca5e7ae412a3f4e53125f99b2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b3570d8c03a761d39b9cacaf4f058d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#ad5b3570d8c03a761d39b9cacaf4f058d">Chebyshev_fit</a> (<a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> &amp;H, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> &amp;P, double(*f)(double _x, double _y, double _z), double ef, double de, int np)</td></tr>
<tr class="separator:ad5b3570d8c03a761d39b9cacaf4f058d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5df952965022e2821218d5cdf3caeb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#ab5df952965022e2821218d5cdf3caeb4">export_calculators_objects</a> ()</td></tr>
<tr class="separator:ab5df952965022e2821218d5cdf3caeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaefba38790cefb92281d4f8c8c8c923c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaefba38790cefb92281d4f8c8c8c923c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_PYTHON_MODULE</b> (libcalculators)</td></tr>
<tr class="separator:aaefba38790cefb92281d4f8c8c8c923c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74703214b88f8de29ae72c251c17b545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a74703214b88f8de29ae72c251c17b545">update_Mull_orb_pop</a> (<a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *P, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> *S, vector&lt; double &gt; &amp;Mull_orb_pop_gross, vector&lt; double &gt; &amp;Mull_orb_pop_net)</td></tr>
<tr class="separator:a74703214b88f8de29ae72c251c17b545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48aacf3d80ac574720367dce2a8898a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48aacf3d80ac574720367dce2a8898a5"></a>
boost::python::list&#160;</td><td class="memItemRight" valign="bottom"><b>update_Mull_orb_pop</b> (<a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> P, <a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> S)</td></tr>
<tr class="separator:a48aacf3d80ac574720367dce2a8898a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d49f950cf369f3d2cd85f8c5bf3e87c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a9d49f950cf369f3d2cd85f8c5bf3e87c">update_Mull_charges</a> (vector&lt; int &gt; &amp;fragment, vector&lt; int &gt; &amp;basis_fo, vector&lt; vector&lt; int &gt; &gt; &amp;at_orbitals, vector&lt; double &gt; &amp;Zeff, vector&lt; double &gt; &amp;Mull_orb_pop_gross, vector&lt; double &gt; &amp;Mull_orb_pop_net, vector&lt; double &gt; &amp;Mull_charges_gross, vector&lt; double &gt; &amp;Mull_charges_net)</td></tr>
<tr class="separator:a9d49f950cf369f3d2cd85f8c5bf3e87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483834a7ccb474020ce126b8cf500f8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliblibra_1_1libcalculators.html#a483834a7ccb474020ce126b8cf500f8a">update_Mull_charges</a> (vector&lt; int &gt; &amp;ao_to_atom_map, vector&lt; double &gt; &amp;Zeff, vector&lt; double &gt; &amp;Mull_orb_pop_gross, vector&lt; double &gt; &amp;Mull_orb_pop_net, vector&lt; double &gt; &amp;Mull_charges_gross, vector&lt; double &gt; &amp;Mull_charges_net)</td></tr>
<tr class="separator:a483834a7ccb474020ce126b8cf500f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a05bbb07e2cf34bf04e96364ee72c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7a05bbb07e2cf34bf04e96364ee72c4"></a>
boost::python::list&#160;</td><td class="memItemRight" valign="bottom"><b>update_Mull_charges</b> (vector&lt; int &gt; &amp;ao_to_atom_map, vector&lt; double &gt; &amp;Zeff, vector&lt; double &gt; &amp;Mull_orb_pop_gross, vector&lt; double &gt; &amp;Mull_orb_pop_net)</td></tr>
<tr class="separator:aa7a05bbb07e2cf34bf04e96364ee72c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>libcalculators namespace </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a2ca1c77eb71b4757a13c4dd9b6e5ecd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcalculators::annihilate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Na</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>Pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>Pb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>Ra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>Rb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Auxiliary function for spin annihilation</p>
<p>This function pre-computes the annihilation corrected density matrices for both spin channels, but does not change the original density matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Na</td><td>the number of alpha electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nb</td><td>the number of beta electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pa</td><td>The pointer to the original density matrix for alpha-channel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pb</td><td>The pointer to the original density matrix for beta-channel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ra</td><td>The pointer to the spin-annihilated density matrix for alpha-channel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Rb</td><td>The pointer to the spin-annihilated density matrix for beta-channel</td></tr>
  </table>
  </dd>
</dl>
<p>According to Eqs. 2.19 - 2.21 from Pople, Beveridge, Dobosh JCP 47, 2026 (1967)</p>

</div>
</div>
<a class="anchor" id="ab1eb2424ace7d692627f5dfbad5afff9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcalculators::annihilate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Na</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>Pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>Pb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function for spin annihilation</p>
<p>This function pre-computes the annihilation-corrected density matrices and change the original density matrices to the annihilated density matrices</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Na</td><td>the number of alpha electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nb</td><td>the number of beta electrons </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Pa</td><td>The pointer to the original density matrix for alpha-channel </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Pb</td><td>The pointer to the original density matrix for beta-channel</td></tr>
  </table>
  </dd>
</dl>
<p>According to Eqs. 2.19 - 2.21 from Pople, Beveridge, Dobosh JCP 47, 2026 (1967)</p>

</div>
</div>
<a class="anchor" id="aaa8daca5e7ae412a3f4e53125f99b2f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcalculators::Chebyshev_coeff </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(double x, double y, double z)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>de</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>According to Numerical Recipes</p>
<p>Computes expansion coefficients of scalar Fermi function C - must be initialized and contains N elements: C[0]... C[N-1] double (*f)(double x, double y, double z) -is a scalar function which we are approximating ef - trial parameter (Fermi energy, upper or lower eigenvalue) de - energy width parameter (smaller it is, the higher the accuracy, but is slower calculation) np - degree of polynomial expansion</p>

</div>
</div>
<a class="anchor" id="ad5b3570d8c03a761d39b9cacaf4f058d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double liblibra::libcalculators::Chebyshev_fit </td>
          <td>(</td>
          <td class="paramtype">MATRIX &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(double _x, double _y, double _z)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>de</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute density matrix using Chebyshev polynomials Return trace of the density matrix, for it should be equal to the number of electrons</p>

</div>
</div>
<a class="anchor" id="a87aab62ca22a49dfd09b9ef7167b8977"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcalculators::compute_density_matrix </td>
          <td>(</td>
          <td class="paramtype">vector&lt; pair&lt; int, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>occ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Straightforward density matrix computation</p>
<p>Scales as O(Norb^3) P = C * N * C.T(), where N - is diagonal - populations in MO basis</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">occ</td><td>Occupations of the molecular orbitals (list of MO-index/MO-occupation pairs), represents N </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>Pointer the matrix of the MO-LCAO coefficients </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>Pointer to the density matrix (in AO basis)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d773805b4e811dc1e3cf7b8bd0c5ce3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcalculators::compute_density_matrix </td>
          <td>(</td>
          <td class="paramtype">vector&lt; pair&lt; int, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>occ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX *&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Straightforward density matrix computation - complex-valued version</p>
<p>Scales as O(Norb^3) P = C * N * C.H(), where N - is diagonal - populations in MO basis</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">occ</td><td>Occupations of the molecular orbitals (list of MO-index/MO-occupation pairs), represents N </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>Pointer to the matrix of the MO-LCAO coefficients </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>Pointer to the density matrix (in AO basis)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac13b6c4c284faa77ae369dc03cf05a42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classliblibra_1_1liblinalg_1_1MATRIX.html">MATRIX</a> liblibra::libcalculators::compute_density_matrix </td>
          <td>(</td>
          <td class="paramtype">boost::python::list&#160;</td>
          <td class="paramname"><em>occ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Straightforward density matrix computation (Python-friendly)</p>
<p>Scales as O(Norb^3) P = C * N * C.T(), where N - is diagonal - populations in MO basis</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">occ</td><td>Occupations of the molecular orbitals (Python list of MO-index/MO-occupation pairs), represents N </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>The matrix of the MO-LCAO coefficients Density matrix (in AO basis) is returned as a MATRIX object</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c777a309a6762efacc7afd2d5f187e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classliblibra_1_1liblinalg_1_1CMATRIX.html">CMATRIX</a> liblibra::libcalculators::compute_density_matrix </td>
          <td>(</td>
          <td class="paramtype">boost::python::list&#160;</td>
          <td class="paramname"><em>occ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Straightforward density matrix computation (Python-friendly, complex-valued)</p>
<p>Scales as O(Norb^3) P = C * N * C.H(), where N - is diagonal - populations in MO basis</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">occ</td><td>Occupations of the molecular orbitals (Python list of MO-index/MO-occupation pairs), represents N </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>The matrix of the MO-LCAO coefficients Density matrix (in AO basis) is returned as a MATRIX object</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91a3f91f582f91cc292f2ad416f53d2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcalculators::convert_1 </td>
          <td>(</td>
          <td class="paramtype">boost::python::list&#160;</td>
          <td class="paramname"><em>bands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>int_bands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Auxiliary converter function</p>
<p>This function converts Python list into vector of pairs, so we can conveniently conver input in Python-friendly functions, to use internal functions</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bands</td><td>The Python input - it is expected to be the list of 2-element lists </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">int_bands</td><td>The C++ output - the vector of pairs</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adda8c673c95b439f5e11e4f35db9889d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::python::list liblibra::libcalculators::convert_2 </td>
          <td>(</td>
          <td class="paramtype">vector&lt; pair&lt; int, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bands</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Auxiliary converter function</p>
<p>This function converts C++ vector of pairs into Python list</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bands</td><td>The C++ input - the vector of pairs The function returns a list of 2-element lists</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae29ddbbfcd0a7e84e9b1cc24f66fa589"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double liblibra::libcalculators::energy_elec </td>
          <td>(</td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>Pao</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>Hao</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>Fao</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Electronic energy</p>
<p>Compute electronic energy (true for HF-derived methods: HF, CNDO, CNDO/2, INDO) this general formula is also true for EHT (F = Hcore, so the energy is simply a weighted sum of the eigenvalues)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pao</td><td>Pointer to the density matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Hao</td><td>Pointer to the core Hamiltonian matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Fao</td><td>Pointer to the Fock matrix</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ef10eb37546791c1581902293f6d371"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double liblibra::libcalculators::energy_elec </td>
          <td>(</td>
          <td class="paramtype">MATRIX&#160;</td>
          <td class="paramname"><em>Pao</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX&#160;</td>
          <td class="paramname"><em>Hao</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX&#160;</td>
          <td class="paramname"><em>Fao</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Electronic energy (Python-friendly)</p>
<p>Compute electronic energy (true for HF-derived methods: HF, CNDO, CNDO/2, INDO) this general formula is also true for EHT (F = Hcore, so the energy is simply a weighted sum of the eigenvalues)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pao</td><td>The density matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Hao</td><td>The core Hamiltonian matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Fao</td><td>The Fock matrix</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af404ad14cdd3651d7602fa35cec13f3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double liblibra::libcalculators::energy_elec </td>
          <td>(</td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>P_alp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>P_bet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>Hao_alp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>Hao_bet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>Fao_alp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>Fao_bet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>dFao_alp_dP_alp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>dFao_alp_dP_bet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>dFao_bet_dP_alp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>dFao_bet_dP_bet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Electronic energy for the charge-dependent Fock matrices (e.g. in SC-EHT)</p>
<p>Note: this energy definition correct for the only case when the Fock matrix is corrected only by the function linear in the corresponding component of the density matrix. Otherwise, we need a tensor contraction scheme</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pao_alp</td><td>Pointer to the density matrix for alpha electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pao_bet</td><td>Pointer to the density matrix for beta electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Hao_alp</td><td>Pointer to the core Hamiltonian matrix for alpha electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Hao_bet</td><td>Pointer to the core Hamiltonian matrix for bet electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Fao_alp</td><td>Pointer to the Fock Hamiltonian matrix for alpha electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Fao_bet</td><td>Pointer to the Fock Hamiltonian matrix for bet electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dFao_alp_dP_alp</td><td>Pointer to the matrix with the derivatives of the Fock matrix for alpha electrons w.r.t to the density matrix for alpha electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dFao_alp_dP_bet</td><td>Pointer to the matrix with the derivatives of the Fock matrix for alpha electrons w.r.t to the density matrix for beta electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dFao_bet_dP_alp</td><td>Pointer to the matrix with the derivatives of the Fock matrix for beta electrons w.r.t to the density matrix for alpha electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dFao_bet_dP_bet</td><td>Pointer to the matrix with the derivatives of the Fock matrix for beta electrons w.r.t to the density matrix for beta electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">temp</td><td>Is just a temporary array - preallocate it before calling this function this will give some acceleration if the energy function is called very often</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d3bd75e6ac8d1636c8093627bce35eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double liblibra::libcalculators::energy_elec </td>
          <td>(</td>
          <td class="paramtype">MATRIX&#160;</td>
          <td class="paramname"><em>P_alp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX&#160;</td>
          <td class="paramname"><em>P_bet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX&#160;</td>
          <td class="paramname"><em>Hao_alp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX&#160;</td>
          <td class="paramname"><em>Hao_bet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX&#160;</td>
          <td class="paramname"><em>Fao_alp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX&#160;</td>
          <td class="paramname"><em>Fao_bet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX&#160;</td>
          <td class="paramname"><em>dFao_alp_dP_alp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX&#160;</td>
          <td class="paramname"><em>dFao_alp_dP_bet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX&#160;</td>
          <td class="paramname"><em>dFao_bet_dP_alp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX&#160;</td>
          <td class="paramname"><em>dFao_bet_dP_bet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX&#160;</td>
          <td class="paramname"><em>temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Electronic energy for the charge-dependent Fock matrices (e.g. in SC-EHT) - Python-friendly</p>
<p>Note: this energy definition correct for the only case when the Fock matrix is corrected only by the function linear in the corresponding component of the density matrix. Otherwise, we need a tensor contraction scheme</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pao_alp</td><td>The density matrix for alpha electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pao_bet</td><td>The density matrix for beta electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Hao_alp</td><td>The core Hamiltonian matrix for alpha electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Hao_bet</td><td>The core Hamiltonian matrix for bet electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Fao_alp</td><td>The Fock Hamiltonian matrix for alpha electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Fao_bet</td><td>The Fock Hamiltonian matrix for bet electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dFao_alp_dP_alp</td><td>The matrix with the derivatives of the Fock matrix for alpha electrons w.r.t to the density matrix for alpha electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dFao_alp_dP_bet</td><td>The matrix with the derivatives of the Fock matrix for alpha electrons w.r.t to the density matrix for beta electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dFao_bet_dP_alp</td><td>The matrix with the derivatives of the Fock matrix for beta electrons w.r.t to the density matrix for alpha electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dFao_bet_dP_bet</td><td>The matrix with the derivatives of the Fock matrix for beta electrons w.r.t to the density matrix for beta electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">temp</td><td>Is just a temporary array - preallocate it before calling this function this will give some acceleration if the energy function is called very often</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3627722b83a86e3658dbdf53530101d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double liblibra::libcalculators::energy_nucl </td>
          <td>(</td>
          <td class="paramtype">vector&lt; VECTOR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Zeff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute nuclear energy of a sub-system</p>
<p>Simple nuclear-nuclear Coulombic interaction</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>Coordinates of all atoms in the system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Zeff</td><td>effective charges of all atoms in the system</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6fabf63eac56f6c77adef986b08a370f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double liblibra::libcalculators::energy_nucl </td>
          <td>(</td>
          <td class="paramtype">vector&lt; VECTOR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Zeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; VECTOR &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute nuclear energy and energy gradients of a sub-system</p>
<p>Simple nuclear-nuclear Coulombic interaction. Derivatives w.r.t. all coordinates</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>Coordinates of all atoms in the system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Zeff</td><td>Effective charges of all atoms in the system </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">G</td><td>Will contain gradients w.r.t. to each nuclear coordinates</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac3fe770ee31c4326e5cb1c02aece3c51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcalculators::excite </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>occ_ini</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>occ_fin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a list representing a I &ndash;&gt; J ecxitation</p>
<p>basically, vector&lt; pair&lt;int,double&gt; &gt; datastructure represents Slater determinant (by selecting ordering of orbitals in the active space)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">occ_ini</td><td>initial occupation list </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">occ_fin</td><td>final occupation list</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab40c54b5f7ce70ae0844ed6baa087500"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::python::list liblibra::libcalculators::excite </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::python::list&#160;</td>
          <td class="paramname"><em>occ_ini</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a list representing a I &ndash;&gt; J ecxitation (Python-friendly)</p>
<p>basically, vector&lt; pair&lt;int,double&gt; &gt; datastructure represents Slater determinant (by selecting ordering of orbitals in the active space) Returns the final occupation list</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">occ_ini</td><td>initial occupation list</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5df952965022e2821218d5cdf3caeb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcalculators::export_calculators_objects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exporter of libcalculators classes and functions</p>

</div>
</div>
<a class="anchor" id="a906ac3f0d2582392ccf7cf43a166003c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double liblibra::libcalculators::fermi_energy </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>bnds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Nel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>degen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>kT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>etol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fermi energy solver</p>
<p>Computes Fermi energy by solving equation fermi_integral( ... ef ... ) = Nel Using bisection method</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bnds</td><td>Input band (energy level index and the energy) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nel</td><td>The number of electrons to distribute on energy levels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degen</td><td>Degeneracy of the energy levels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kT</td><td>Broadening factor for Fermi distribution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">etol</td><td>Tolerance level (stop when 0.5*|e_f(old) - e_f(new)|&lt;tol)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af465db9b9ab0bc13f9e6edac49c9bad4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double liblibra::libcalculators::fermi_energy </td>
          <td>(</td>
          <td class="paramtype">boost::python::list&#160;</td>
          <td class="paramname"><em>bnds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Nel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>degen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>kT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>etol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fermi energy solver (Python-friendly version)</p>
<p>Computes Fermi energy by solving equation fermi_integral( ... ef ... ) = Nel Using bisection method</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bnds</td><td>Input band (energy level index and the energy) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nel</td><td>The number of electrons to distribute on energy levels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degen</td><td>Degeneracy of the energy levels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kT</td><td>Broadening factor for Fermi distribution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">etol</td><td>Tolerance level (stop when 0.5*|e_f(old) - e_f(new)|&lt;tol)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ee9c2af406453bf6be966de9b495d05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double liblibra::libcalculators::fermi_integral </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>bnds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>degen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>kT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Auxiliary function to compute Fermi integral</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bnds</td><td>Compute integral(actually the sum): sum [degen / (1 + exp(e-ef))] i where N - is a number of electrons (valence) double kT = 0.00095; // kT in a.u. for T = 300 K</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bnds</td><td>Input band (energy level index and the energy) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ef</td><td>Fermi energy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degen</td><td>Degeneracy of the energy levels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kT</td><td>Broadening factor for Fermi distribution</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5bb0e8685c58bbe27fe34b26a2361ea9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double liblibra::libcalculators::fermi_integral </td>
          <td>(</td>
          <td class="paramtype">boost::python::list&#160;</td>
          <td class="paramname"><em>bnds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>degen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>kT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Auxiliary function to compute Fermi integral (Python-friendly)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bnds</td><td>Compute integral(actually the sum): sum [degen / (1 + exp(e-ef))] i where N - is a number of electrons (valence) double kT = 0.00095; // kT in a.u. for T = 300 K</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bnds</td><td>Input band (energy level index and the energy) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ef</td><td>Fermi energy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degen</td><td>Degeneracy of the energy levels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kT</td><td>Broadening factor for Fermi distribution</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac12732fe06e2dbb44e85e327f9111e20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double liblibra::libcalculators::fermi_population </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>degen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>kT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fermi populations.</p>
<p>Compute Fermi-based occupation of energy level with energy e ef - is the assumed Fermi energy double kT = 0.00095; kT in a.u. for T = 300 K</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Energy level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ef</td><td>Fermi energy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degen</td><td>Degeneracy of the energy levels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kT</td><td>Broadening factor for Fermi distribution</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a79df6f0b856d4aa59a7ba5db6ca1aaaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcalculators::Fock_to_P </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Norb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nocc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>degen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Nel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>eigen_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pop_opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>Fao</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>Sao</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>occ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Timer &gt; &amp;&#160;</td>
          <td class="paramname"><em>bench_t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set of instructions to compute density matrix from the Fock matrix</p>
<p>This is a somewhat older version</p>
<p>Iterative unit: from a given Hamiltonian (Fock matrix) we obtain density matrix In these steps there is no coupling of spin-up and spin-down channels, so they can be solved one by one, independently. 1) solve Fao * C = Sao * C * E 2) order bands 3) compute P as P = C * N * C.T(), where N = occ</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Norb</td><td>The number of orbitals = the dimensionality of electronic problem </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nocc</td><td>The number of occupied (integer occupation) orbitals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degen</td><td>Dengeneracy of orbitals (the maximal number of electrons that can occupay one orbital) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nel</td><td>The number of electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eigen_method</td><td>The flag controlling the assumer orthogonality of basis orbitals: eigen_method = "generalized" - non-orthogonal orbitals are assumed, solve a generalized eigenvalue problem eigen_method = "standard" - orthogonal orbitals are assumed, solve standard eigenvalue problem </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pop_opt</td><td>The flag controlling the population scheme pop_opt = 0 - integer occupation numbers will be used (good in many standard cases) pop_opt = 1 - fractional occupations will be possible (can help in difficult cases) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Fao</td><td>The pointer to the Fock matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Sao</td><td>The pointer to the AO overlap matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td>The pointer to MO-LCAO matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>The pointer to the eigenvalues (of the Fock operator) matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bands</td><td>The orbital energies in the vector of pairs format </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">occ</td><td>The orbital occupancies (MO basis populations) in the vector of pairs format </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">P</td><td>The pointer to the density matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bench_t</td><td>The benchmarking information: bench_t[0] - eigenvalue solvers, bench_t[1] - ordering bands, bench_t[2] - populate bands, bench_t[3] - density matrix computations</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3bd52bf6137a6250210f4c576807dc2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcalculators::Fock_to_P </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Norb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nocc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>degen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Nel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>eigen_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pop_opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX *&#160;</td>
          <td class="paramname"><em>Fao</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX *&#160;</td>
          <td class="paramname"><em>Sao</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX *&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>occ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Timer &gt; &amp;&#160;</td>
          <td class="paramname"><em>bench_t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set of instructions to compute density matrix from the Fock matrix - assuming the complex-valued Fock and MO matrices</p>
<p>This is a somewhat older version</p>
<p>Iterative unit: from a given Hamiltonian (Fock matrix) we obtain density matrix In these steps there is no coupling of spin-up and spin-down channels, so they can be solved one by one, independently. 1) solve Fao * C = Sao * C * E 2) order bands 3) compute P as P = C * N * C.H(), where N = occ</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Norb</td><td>The number of orbitals = the dimensionality of electronic problem </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nocc</td><td>The number of occupied (integer occupation) orbitals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degen</td><td>Dengeneracy of orbitals (the maximal number of electrons that can occupay one orbital) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nel</td><td>The number of electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eigen_method</td><td>The flag controlling the assumer orthogonality of basis orbitals: eigen_method = "generalized" - non-orthogonal orbitals are assumed, solve a generalized eigenvalue problem eigen_method = "standard" - orthogonal orbitals are assumed, solve standard eigenvalue problem </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pop_opt</td><td>The flag controlling the population scheme pop_opt = 0 - integer occupation numbers will be used (good in many standard cases) pop_opt = 1 - fractional occupations will be possible (can help in difficult cases) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Fao</td><td>The pointer to the Fock matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Sao</td><td>The pointer to the AO overlap matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td>The pointer to MO-LCAO matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>The pointer to the eigenvalues (of the Fock operator) matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bands</td><td>The orbital energies in the vector of pairs format </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">occ</td><td>The orbital occupancies (MO basis populations) in the vector of pairs format </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">P</td><td>The pointer to the density matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bench_t</td><td>The benchmarking information: bench_t[0] - eigenvalue solvers, bench_t[1] - ordering bands, bench_t[2] - populate bands, bench_t[3] - density matrix computations</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25b9b88c75a62459e7010e6eaa00e9ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcalculators::Fock_to_P </td>
          <td>(</td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>Fao</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>Sao</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Nel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>degen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>kT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>etol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pop_opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>occ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>BM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Timer &gt; &amp;&#160;</td>
          <td class="paramname"><em>bench_t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set of instructions to compute density matrix from the Fock matrix</p>
<p>This is a newer version - takes less argiments and makes some inferrences</p>
<p>Iterative unit: from a given Hamiltonian (Fock matrix) we obtain density matrix In these steps there is no coupling of spin-up and spin-down channels, so they can be solved one by one, independently. 1) solve Fao * C = Sao * C * E 2) order bands 3) compute P as P = C * N * C.T(), where N = occ</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Fao</td><td>The pointer to the Fock matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Sao</td><td>The pointer to the AO overlap matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nel</td><td>The number of electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degen</td><td>Dengeneracy of orbitals (the maximal number of electrons that can occupay one orbital) [in] kT Broadening factor for Fermi distribution [in] etol Tolerance level (stop when 0.5*|e_f(old) - e_f(new)|&lt;tol) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pop_opt</td><td>The flag controlling the population scheme pop_opt = 0 - integer occupation numbers will be used (good in many standard cases) pop_opt = 1 - fractional occupations will be possible (can help in difficult cases) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>The pointer to the eigenvalues (of the Fock operator) matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td>The pointer to MO-LCAO matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">P</td><td>The pointer to the density matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bands</td><td>The orbital energies in the vector of pairs format </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">occ</td><td>The orbital occupancies (MO basis populations) in the vector of pairs format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BM</td><td>Benchmark flag: = 0 - don't do benchmarking, 1 - do it </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bench_t</td><td>The benchmarking information: bench_t[0] - eigenvalue solvers, bench_t[1] - ordering bands, bench_t[2] - populate bands, bench_t[3] - density matrix computations</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5032fe2892b5d39d1ef7fbfc8784a8ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcalculators::Fock_to_P </td>
          <td>(</td>
          <td class="paramtype">CMATRIX *&#160;</td>
          <td class="paramname"><em>Fao</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX *&#160;</td>
          <td class="paramname"><em>Sao</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Nel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>degen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>kT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>etol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pop_opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX *&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>occ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>BM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Timer &gt; &amp;&#160;</td>
          <td class="paramname"><em>bench_t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set of instructions to compute density matrix from the Fock matrix - complex-valued version</p>
<p>This is a newer version - takes less argiments and makes some inferrences</p>
<p>Iterative unit: from a given Hamiltonian (Fock matrix) we obtain density matrix In these steps there is no coupling of spin-up and spin-down channels, so they can be solved one by one, independently. 1) solve Fao * C = Sao * C * E 2) order bands 3) compute P as P = C * N * C.H(), where N = occ</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Fao</td><td>The pointer to the Fock matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Sao</td><td>The pointer to the AO overlap matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nel</td><td>The number of electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degen</td><td>Dengeneracy of orbitals (the maximal number of electrons that can occupay one orbital) [in] kT Broadening factor for Fermi distribution [in] etol Tolerance level (stop when 0.5*|e_f(old) - e_f(new)|&lt;tol) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pop_opt</td><td>The flag controlling the population scheme pop_opt = 0 - integer occupation numbers will be used (good in many standard cases) pop_opt = 1 - fractional occupations will be possible (can help in difficult cases) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>The pointer to the eigenvalues (of the Fock operator) matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td>The pointer to MO-LCAO matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">P</td><td>The pointer to the density matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bands</td><td>The orbital energies in the vector of pairs format </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">occ</td><td>The orbital occupancies (MO basis populations) in the vector of pairs format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BM</td><td>Benchmark flag: = 0 - don't do benchmarking, 1 - do it </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bench_t</td><td>The benchmarking information: bench_t[0] - eigenvalue solvers, bench_t[1] - ordering bands, bench_t[2] - populate bands, bench_t[3] - density matrix computations</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ca9a5c855d5780e50f4f7017bf1751a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcalculators::Fock_to_P </td>
          <td>(</td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>Fao</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>Sao</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Nel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>degen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>kT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>etol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pop_opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>occ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set of instructions to compute density matrix from the Fock matrix</p>
<p>This is a newer version - even simpler: no benchmarking</p>
<p>Iterative unit: from a given Hamiltonian (Fock matrix) we obtain density matrix In these steps there is no coupling of spin-up and spin-down channels, so they can be solved one by one, independently. 1) solve Fao * C = Sao * C * E 2) order bands 3) compute P as P = C * N * C.T(), where N = occ</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Fao</td><td>The pointer to the Fock matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Sao</td><td>The pointer to the AO overlap matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nel</td><td>The number of electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degen</td><td>Dengeneracy of orbitals (the maximal number of electrons that can occupay one orbital) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kT</td><td>Broadening factor for Fermi distribution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">etol</td><td>Tolerance level (stop when 0.5*|e_f(old) - e_f(new)|&lt;tol) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pop_opt</td><td>The flag controlling the population scheme pop_opt = 0 - integer occupation numbers will be used (good in many standard cases) pop_opt = 1 - fractional occupations will be possible (can help in difficult cases) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>The pointer to the eigenvalues (of the Fock operator) matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td>The pointer to MO-LCAO matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">P</td><td>The pointer to the density matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bands</td><td>The orbital energies in the vector of pairs format </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">occ</td><td>The orbital occupancies (MO basis populations) in the vector of pairs format</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a88932eee16691eec40bc93a06f4d7993"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcalculators::Fock_to_P </td>
          <td>(</td>
          <td class="paramtype">CMATRIX *&#160;</td>
          <td class="paramname"><em>Fao</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX *&#160;</td>
          <td class="paramname"><em>Sao</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Nel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>degen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>kT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>etol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pop_opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX *&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>occ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set of instructions to compute density matrix from the Fock matrix - complex-valued version</p>
<p>This is a newer version - even simpler: no benchmarking</p>
<p>Iterative unit: from a given Hamiltonian (Fock matrix) we obtain density matrix In these steps there is no coupling of spin-up and spin-down channels, so they can be solved one by one, independently. 1) solve Fao * C = Sao * C * E 2) order bands 3) compute P as P = C * N * C.H(), where N = occ</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Fao</td><td>The pointer to the Fock matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Sao</td><td>The pointer to the AO overlap matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nel</td><td>The number of electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degen</td><td>Dengeneracy of orbitals (the maximal number of electrons that can occupay one orbital) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kT</td><td>Broadening factor for Fermi distribution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">etol</td><td>Tolerance level (stop when 0.5*|e_f(old) - e_f(new)|&lt;tol) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pop_opt</td><td>The flag controlling the population scheme pop_opt = 0 - integer occupation numbers will be used (good in many standard cases) pop_opt = 1 - fractional occupations will be possible (can help in difficult cases) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>The pointer to the eigenvalues (of the Fock operator) matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td>The pointer to MO-LCAO matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">P</td><td>The pointer to the density matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bands</td><td>The orbital energies in the vector of pairs format </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">occ</td><td>The orbital occupancies (MO basis populations) in the vector of pairs format</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab578b59ca6c45b60fa21f5dee6889e2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::python::list liblibra::libcalculators::Fock_to_P </td>
          <td>(</td>
          <td class="paramtype">MATRIX&#160;</td>
          <td class="paramname"><em>Fao</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX&#160;</td>
          <td class="paramname"><em>Sao</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Nel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>degen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>kT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>etol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pop_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set of instructions to compute density matrix from the Fock matrix</p>
<p>The simplest and Python-friendly version</p>
<p>Iterative unit: from a given Hamiltonian (Fock matrix) we obtain density matrix In these steps there is no coupling of spin-up and spin-down channels, so they can be solved one by one, independently. 1) solve Fao * C = Sao * C * E 2) order bands 3) compute P as P = C * N * C.T(), where N = occ</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Fao</td><td>The Fock matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Sao</td><td>The AO overlap matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nel</td><td>The number of electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degen</td><td>Dengeneracy of orbitals (the maximal number of electrons that can occupay one orbital) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kT</td><td>Broadening factor for Fermi distribution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">etol</td><td>Tolerance level (stop when 0.5*|e_f(old) - e_f(new)|&lt;tol) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pop_opt</td><td>The flag controlling the population scheme pop_opt = 0 - integer occupation numbers will be used (good in many standard cases) pop_opt = 1 - fractional occupations will be possible (can help in difficult cases) Returns the list of the objects: res[0] = E (eigenvalues matrix), res[1] = C (eigenvectors matrix), res[2] = P (density matrix), res[3] = bands (energies, list of lists), res[4] = occ (occupations, list of lists)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10afb78ccc7278e1f5b8c3f52e60ca7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::python::list liblibra::libcalculators::Fock_to_P </td>
          <td>(</td>
          <td class="paramtype">CMATRIX&#160;</td>
          <td class="paramname"><em>Fao</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMATRIX&#160;</td>
          <td class="paramname"><em>Sao</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Nel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>degen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>kT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>etol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pop_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set of instructions to compute density matrix from the Fock matrix - complex-valued version</p>
<p>The simplest and Python-friendly version</p>
<p>Iterative unit: from a given Hamiltonian (Fock matrix) we obtain density matrix In these steps there is no coupling of spin-up and spin-down channels, so they can be solved one by one, independently. 1) solve Fao * C = Sao * C * E 2) order bands 3) compute P as P = C * N * C.H(), where N = occ</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Fao</td><td>The Fock matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Sao</td><td>The AO overlap matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nel</td><td>The number of electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degen</td><td>Dengeneracy of orbitals (the maximal number of electrons that can occupay one orbital) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kT</td><td>Broadening factor for Fermi distribution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">etol</td><td>Tolerance level (stop when 0.5*|e_f(old) - e_f(new)|&lt;tol) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pop_opt</td><td>The flag controlling the population scheme pop_opt = 0 - integer occupation numbers will be used (good in many standard cases) pop_opt = 1 - fractional occupations will be possible (can help in difficult cases) Returns the list of the objects: res[0] = E (eigenvalues matrix), res[1] = C (eigenvectors matrix), res[2] = P (density matrix), res[3] = bands (energies, list of lists), res[4] = occ (occupations, list of lists)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80b90f9c903ecb93e8f07f01fcd6c035"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcalculators::order_bands </td>
          <td>(</td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ordering of bands</p>
<p>This function takes the diagonal elements of the E matrix, orders them and packs into a vector of pairs. Each pair is contains the index of the state (in the original, petentially disordered, structure E) and the corresponding value of the matrix element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>The pointer to the diagonal matrix with energies </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bands</td><td>The packed structure containing ordered eigenvalues and their original ordering indices</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4173ec2c134c623cf36e964e1f8b5955"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::python::list liblibra::libcalculators::order_bands </td>
          <td>(</td>
          <td class="paramtype">MATRIX&#160;</td>
          <td class="paramname"><em>E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ordering of bands (Python-friendly version)</p>
<p>This function takes the diagonal elements of the E matrix, orders them and packs into a vector of pairs. Each pair is contains the index of the state (in the original, petentially disordered, structure E) and the corresponding value of the matrix element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>The diagonal matrix with energies The function returns the packed structure (represented as a list of 2-element lists) containing ordered eigenvalues and their original ordering indices</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3eb0a09044e9439992384c8eb874ca99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double liblibra::libcalculators::p_up </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>e_up</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>de</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For FOE: Fermi operator expansion. </p>
<p>========= The following functions are needed for FOE: Fermi Operator Expansion - a linear-scaling electronic structure methodology </p>

</div>
</div>
<a class="anchor" id="a2c4d2f51ae875643c3e21586b3112c00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcalculators::populate_bands </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Nel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>degen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>kT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>etol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pop_opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>occ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute populations of bands</p>
<p>The function computes populations of bands, depending on the chosen poulation scheme and the corresponding parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Nel</td><td>The number of electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degen</td><td>Dengeneracy of orbitals (the maximal number of electrons that can occupay one orbital) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kT</td><td>Broadening factor for Fermi distribution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">etol</td><td>Tolerance level (stop when 0.5*|e_f(old) - e_f(new)|&lt;tol) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pop_opt</td><td>The flag controlling the population scheme pop_opt = 0 - integer occupation numbers will be used (good in many standard cases) pop_opt = 1 - fractional occupations will be possible (can help in difficult cases) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bands</td><td>The packed structure containing ordered eigenvalues and their original ordering indices </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">occ</td><td>The packed structure containing populations of the energy levels packed in bands</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ed1a5eb32ebb8feec22d13a7bc618d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::python::list liblibra::libcalculators::populate_bands </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Nel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>degen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>kT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>etol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pop_opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::python::list&#160;</td>
          <td class="paramname"><em>bands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute populations of bands (Python-friendly version)</p>
<p>The function computes populations of bands, depending on the chosen poulation scheme and the corresponding parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Nel</td><td>The number of electrons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degen</td><td>Dengeneracy of orbitals (the maximal number of electrons that can occupay one orbital) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kT</td><td>Broadening factor for Fermi distribution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">etol</td><td>Tolerance level (stop when 0.5*|e_f(old) - e_f(new)|&lt;tol) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pop_opt</td><td>The flag controlling the population scheme pop_opt = 0 - integer occupation numbers will be used (good in many standard cases) pop_opt = 1 - fractional occupations will be possible (can help in difficult cases) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bands</td><td>The packed structure containing ordered eigenvalues and their original ordering indices The function returns the packed structure (list of 2-element lists) containing populations of the energy levels packed in bands</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0eecec1eb035e2479331730a69542e8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcalculators::show_bands </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Norb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nocc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>occ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Formatter printout of the bands</p>
<p>The function will print energy levels and the corresponding populations</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Norb</td><td>The number of orbitals to show (starting with index 0) - usually all </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nocc</td><td>The number of occupied orbitals - we just print this number. This parameter is not used in any other way. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bands</td><td>The packed structure containing ordered eigenvalues and their original ordering indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">occ</td><td>The packed structure containing populations of the energy levels packed in bands</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d49f950cf369f3d2cd85f8c5bf3e87c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcalculators::update_Mull_charges </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>fragment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis_fo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>at_orbitals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Zeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Mull_orb_pop_gross</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Mull_orb_pop_net</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Mull_charges_gross</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Mull_charges_net</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update Mulliken charges on atoms</p>
<p>This is older (and not very efficient) version</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fragment</td><td>Contains indices of all nuclei, for which the Mull charges should be updated. So that fragment[a] - is the global index of the a-th atom of the fragment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basis_fo</td><td>Contains the global indices of the basis functions centered on the chosen (by the "fragment" variable) fragment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">at_orbitals</td><td>Mapping bewteen the local indices of the basis functions in the atom set and the global indices of all basis functions. For instance at_orbitals[n][i] is the global index of the i-th basis fucntion of n-th atoms. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Zeff</td><td>Effective charges of all nuclei </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Mull_orb_pop_gross</td><td>Mulliken gross populations on all orbitals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Mull_orb_pop_net</td><td>Mulliken net populations on all orbitals </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Mull_charges_gross</td><td>Mulliken gross charges on all atoms </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Mull_charges_net</td><td>Mulliken net charges on all atoms</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a483834a7ccb474020ce126b8cf500f8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcalculators::update_Mull_charges </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ao_to_atom_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Zeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Mull_orb_pop_gross</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Mull_orb_pop_net</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Mull_charges_gross</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Mull_charges_net</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update Mulliken charges on atoms</p>
<p>This is newer (and more efficient) version</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ao_to_atom_map</td><td>Mapping from the grobal indices of orbitals to the global indices nuclei: ao_to_atom_map[i] - is the index of the atom on which i-th AO is localized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Zeff</td><td>Effective charges of all nuclei </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Mull_orb_pop_gross</td><td>Mulliken gross populations on all orbitals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Mull_orb_pop_net</td><td>Mulliken net populations on all orbitals </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Mull_charges_gross</td><td>Mulliken gross charges on all atoms </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Mull_charges_net</td><td>Mulliken net charges on all atoms</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74703214b88f8de29ae72c251c17b545"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void liblibra::libcalculators::update_Mull_orb_pop </td>
          <td>(</td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Mull_orb_pop_gross</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Mull_orb_pop_net</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recompute(update) Mulliken-type orbital-resolved populations</p>
<p>Compute Mulliken orbital-resolved populations from the density matrix memory for Mull_orb_pop_* is assumed already allocated gross and net populations are computed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>Pointer to the density matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>Pointer to the overlap matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Mull_orb_pop_gross</td><td>The vector which will collect orbital-resolved Mulliken gross populations </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Mull_orb_pop_net</td><td>The vector which will collect orbital-resolved Mulliken net populations</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 25 2017 14:01:30 for Libra by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
